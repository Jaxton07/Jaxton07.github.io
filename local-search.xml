<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Github添加SSH Key</title>
    <link href="/2023/06/28/github%E6%B7%BB%E5%8A%A0SSH%20Key/"/>
    <url>/2023/06/28/github%E6%B7%BB%E5%8A%A0SSH%20Key/</url>
    
    <content type="html"><![CDATA[<h1 id="Github添加SSH-Key"><a href="#Github添加SSH-Key" class="headerlink" title="Github添加SSH Key"></a>Github添加SSH Key</h1>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github下载加速</title>
    <link href="/2022/06/21/Github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/"/>
    <url>/2022/06/21/Github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Github下载加速"><a href="#Github下载加速" class="headerlink" title="Github下载加速"></a>Github下载加速</h1><p>以下网址：</p><pre><code class="hljs powershell">https://ghproxy.com/https://mirror.ghproxy.com/https://gh.api.<span class="hljs-number">99988866</span>.xyz/</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 安装Xrdp 远程桌面</title>
    <link href="/2022/06/21/Linux%20%E5%AE%89%E8%A3%85Xrdp%20%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/"/>
    <url>/2022/06/21/Linux%20%E5%AE%89%E8%A3%85Xrdp%20%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-安装Xrdp-远程桌面"><a href="#Linux-安装Xrdp-远程桌面" class="headerlink" title="Linux 安装Xrdp 远程桌面"></a>Linux 安装Xrdp 远程桌面</h1><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><pre><code class="hljs shell">sudo apt install xrdp</code></pre><p>2.重启Xrdp服务器：</p><pre><code class="hljs shell">sudo service xrdp restart</code></pre><p>3.查看服务运行状态：</p><pre><code class="hljs shell">sudo service xrdp status</code></pre><p>出现active（running）即说明服务已运行。可以使用Windows电脑进行连接啦！</p><p>4.设置开启自动启动（设置开机启动可以在树莓派无屏幕启动时直接远程连接）：</p><pre><code class="hljs shell">sudo update-rc.d xrdp defaults</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows 配置多个 ssh key</title>
    <link href="/2022/06/21/windows%20%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%20ssh%20key/"/>
    <url>/2022/06/21/windows%20%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%20ssh%20key/</url>
    
    <content type="html"><![CDATA[<h1 id="windows-配置多个-ssh-key"><a href="#windows-配置多个-ssh-key" class="headerlink" title="windows 配置多个 ssh key"></a>windows 配置多个 ssh key</h1><p>config文件：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 配置github.com</span>Host github.com                     HostName github.com    IdentityFile C:\\Users\\popfisher\\.ssh\\id_rsa_github    PreferredAuthentications publickey    User username1<span class="hljs-meta">#</span><span class="bash"> 配置git.oschina.net </span>Host git.oschina.net     HostName git.oschina.net    IdentityFile C:\\Users\\popfisher\\.ssh\\id_rsa_oschina    PreferredAuthentications publickey    User username2</code></pre><p>测试：</p><pre><code class="hljs shell">ssh -T git@github.comHi EriWang520! You&#x27;ve successfully authenticated, but GitHub does not provide shell accessssh -T git@gitee.comHi ericW! You&#x27;ve successfully authenticated, but GITEE.COM does not provide shell access.</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改 pip 镜像源</title>
    <link href="/2022/06/11/%E4%BF%AE%E6%94%B9%20pip%20%E9%95%9C%E5%83%8F%E6%BA%90/"/>
    <url>/2022/06/11/%E4%BF%AE%E6%94%B9%20pip%20%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h1 id="修改-pip-镜像源"><a href="#修改-pip-镜像源" class="headerlink" title="修改 pip 镜像源"></a>修改 pip 镜像源</h1><h3 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1.Linux"></a>1.Linux</h3><pre><code class="hljs shell">mkdir  ~/.pipvi  ~/.pip/pip.conf</code></pre><p>添加内容如下：</p><pre><code class="hljs shell">[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO (一)</title>
    <link href="/2021/12/07/IO%20(%E4%B8%80)/"/>
    <url>/2021/12/07/IO%20(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><p>这里总结一下 I/O 相关的知识点，主要是从 linux 的角度。</p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect</a></p><h3 id="阻塞I-O-Blocking-I-O"><a href="#阻塞I-O-Blocking-I-O" class="headerlink" title="阻塞I/O (Blocking I/O)"></a>阻塞I/O (Blocking I/O)</h3><p>先看下图BIO的执行过程：</p><p><img src="https://pic.cloudfor.top/blog/image-20211207172050622.png" alt="image-20211207172050622"></p><p>原博主的图片不太清楚，我重新画了一下。对比一下下面的 NIO 就可以看出区别在哪里了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章记录</title>
    <link href="/2021/11/02/%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/11/02/%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="文章记录"><a href="#文章记录" class="headerlink" title="文章记录"></a>文章记录</h1><p>这里主要记录一下一些不错的博客和文章，避免要重新看的时候找不到。</p><h3 id="1、中间件"><a href="#1、中间件" class="headerlink" title="1、中间件"></a>1、中间件</h3><p><strong>1.RocketMq官方文档</strong></p><p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">https://github.com/apache/rocketmq/tree/master/docs/cn</a></p><p><strong>2.Rocketmq如何保证消息不丢失</strong></p><p><a href="https://blog.csdn.net/leeasony/article/details/104857576">https://blog.csdn.net/leeasony/article/details/104857576</a></p><p><strong>3.dubbo 浅入浅出</strong></p><p><a href="https://zhuanlan.zhihu.com/p/188331820">https://zhuanlan.zhihu.com/p/188331820</a></p><h3 id="2、框架"><a href="#2、框架" class="headerlink" title="2、框架"></a>2、框架</h3><h4 id="1、springboot"><a href="#1、springboot" class="headerlink" title="1、springboot"></a>1、springboot</h4><p><strong>1.springboot 请求处理流程</strong></p><p><a href="https://blog.csdn.net/sinat_37255539/article/details/103838784">https://blog.csdn.net/sinat_37255539/article/details/103838784</a></p><p><strong>2.SPRINGBOOT启动流程及其原理</strong></p><p><a href="https://blog.csdn.net/u014352080/article/details/102716468">https://blog.csdn.net/u014352080/article/details/102716468</a></p><p><strong>3.手把手带你剖析 Spring Boot 启动原理</strong></p><p><a href="https://www.bilibili.com/video/BV1j7411a7wX?from=search&amp;seid=14011837253397843303&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1j7411a7wX?from=search&amp;seid=14011837253397843303&amp;spm_id_from=333.337.0.0</a></p><p><strong>4.清华博士后讲解Java面试题：Spring Boot启动流程和Spring Boot自动装配原理</strong></p><p><a href="https://www.bilibili.com/video/BV1Fp4y1t7WS?from=search&amp;seid=14011837253397843303&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1Fp4y1t7WS?from=search&amp;seid=14011837253397843303&amp;spm_id_from=333.337.0.0</a></p><p><strong>5.spring IOC 和 AOP</strong></p><p><a href="https://zhuanlan.zhihu.com/p/355778555">https://zhuanlan.zhihu.com/p/355778555</a></p><p><a href="https://www.zhihu.com/search?q=ioc%20aop&amp;utm_content=search_suggestion&amp;type=content">https://www.zhihu.com/search?q=ioc%20aop&amp;utm_content=search_suggestion&amp;type=content</a></p><h3 id="3、Java基础"><a href="#3、Java基础" class="headerlink" title="3、Java基础"></a>3、Java基础</h3><h4 id="1、NIO"><a href="#1、NIO" class="headerlink" title="1、NIO"></a>1、NIO</h4><p><strong>1.Java NIO浅析</strong></p><p><a href="https://zhuanlan.zhihu.com/p/23488863">https://zhuanlan.zhihu.com/p/23488863</a></p><p><strong>2.Linux NIO 系列(01) 五种网络 IO 模型</strong></p><p><a href="https://www.cnblogs.com/binarylei/p/8933516.html#11-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4">https://www.cnblogs.com/binarylei/p/8933516.html#11-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4</a></p><p><strong>3.Java NIO？看这一篇就够了！</strong></p><p><a href="https://blog.csdn.net/forezp/article/details/88414741/">https://blog.csdn.net/forezp/article/details/88414741/</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&amp;mid=2247483907&amp;idx=1&amp;sn=3d5e1384a36bd59f5fd14135067af1c2&amp;chksm=fb0be897cc7c61815a6a1c3181f3ba3507b199fd7a8c9025e9d8f67b5e9783bc0f0fe1c73903&amp;scene=21#wechat_redirect</a></p><p><strong>4.清华大牛权威讲解nio,epoll,多路复用，更好的理解redis-netty-Kafka等热门技术</strong></p><p><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV11K4y1C7rm?p=2&amp;spm_id_from=pageDriver</a></p><p><strong>5.select、poll、epoll   -   IO模型超详解</strong></p><p><a href="https://blog.csdn.net/XueyinGuo/article/details/113096163">https://blog.csdn.net/XueyinGuo/article/details/113096163</a></p><p><strong>6.2021新版Java NIO详细教程</strong></p><p><a href="https://www.bilibili.com/video/BV1E64y1h7Z4?p=42&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1E64y1h7Z4?p=42&amp;spm_id_from=pageDriver</a></p><h4 id="2、其他"><a href="#2、其他" class="headerlink" title="2、其他"></a>2、其他</h4><p>1.负载均衡–一致性hash算法</p><p><a href="https://zhuanlan.zhihu.com/p/34969168">https://zhuanlan.zhihu.com/p/34969168</a></p><p>2.<a href="https://www.cnblogs.com/suizhikuo/p/13941272.html">CGLib动态代理原理及实现</a></p><p>3.cas单点登录</p><p><a href="https://blog.csdn.net/qq_41258204/article/details/84036875">https://blog.csdn.net/qq_41258204/article/details/84036875</a></p><p>4.RESTFul</p><p><a href="https://www.zhihu.com/question/28557115/answer/48094438">https://www.zhihu.com/question/28557115/answer/48094438</a></p><h3 id="4、数据库"><a href="#4、数据库" class="headerlink" title="4、数据库"></a>4、数据库</h3><p><strong>1.MySQL如何设计索引更高效？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/343312997">https://zhuanlan.zhihu.com/p/343312997</a></p><p><strong>2.我以为我对Mysql事务很熟，直到我遇到了</strong></p><p><a href="https://zhuanlan.zhihu.com/p/148035779">https://zhuanlan.zhihu.com/p/148035779</a></p><p><strong>3.阿里P8整理Mysql面试题答案</strong></p><p><a href="https://zhuanlan.zhihu.com/p/140876416">https://zhuanlan.zhihu.com/p/140876416</a></p><h3 id="5、设计模式"><a href="#5、设计模式" class="headerlink" title="5、设计模式"></a>5、设计模式</h3><p>1.工厂方法模式、抽象工厂模式、单例模式、建造型模式、原型模式</p><p><a href="https://zhuanlan.zhihu.com/p/85624457">https://zhuanlan.zhihu.com/p/85624457</a></p><p>2.装饰模式、外观模式、享元模式、代理模式</p><p><a href="https://zhuanlan.zhihu.com/p/94159179">https://zhuanlan.zhihu.com/p/94159179</a></p><p>3.适配器模式、桥接模式、组合模式</p><p><a href="https://zhuanlan.zhihu.com/p/91836046">https://zhuanlan.zhihu.com/p/91836046</a></p><h3 id="5、技术站点"><a href="#5、技术站点" class="headerlink" title="5、技术站点"></a>5、技术站点</h3><p>1.美团</p><p><a href="https://tech.meituan.com/">https://tech.meituan.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP状态码</title>
    <link href="/2021/10/29/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2021/10/29/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h4 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h4><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h4 id="2、状态码列表"><a href="#2、状态码列表" class="headerlink" title="2、状态码列表"></a>2、状态码列表</h4><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双亲委派模型</title>
    <link href="/2021/10/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/10/15/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>参考：<a href="https://blog.csdn.net/codeyanbao/article/details/82875064">https://blog.csdn.net/codeyanbao/article/details/82875064</a></p><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>​    在介绍双亲委派机制的时候，不得不提ClassLoader（类加载器）。说ClassLoader之前，我们得先了解下Java的基本知识。  </p><p>Java是运行在Java的虚拟机(JVM)中的，但是它是如何运行在JVM中了呢？我们在IDE中编写的Java源代码被编译器编译成.class的字节码文件。然后由我们得ClassLoader负责将这些class文件给加载到JVM中去执行。  </p><h4 id="2-JVM中提供了三层的ClassLoader："><a href="#2-JVM中提供了三层的ClassLoader：" class="headerlink" title="2.JVM中提供了三层的ClassLoader："></a>2.JVM中提供了三层的ClassLoader：</h4><pre><code>Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。AppClassLoader：主要负责加载应用程序的主函数类</code></pre><h4 id="3-双亲委派"><a href="#3-双亲委派" class="headerlink" title="3.双亲委派"></a>3.双亲委派</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);&#125;<span class="hljs-comment">//              -----??-----</span><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>            &#125;             <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// If still not found, then invoke findClass in order</span>                <span class="hljs-comment">// to find the class.</span>                c = findClass(name);            &#125;        &#125;        <span class="hljs-keyword">return</span> c;&#125;</code></pre><p>其实这段代码已经很好的解释了双亲委派机制</p><p><img src="https://pic.cloudfor.top/blog/20201217213314510.png" alt="img"></p><h4 id="4-为什么要设计这种机制"><a href="#4-为什么要设计这种机制" class="headerlink" title="4.为什么要设计这种机制?"></a>4.为什么要设计这种机制?</h4><p>这种设计有个好处是，如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了（为什么？因为当一个类需要加载的时候，最先去尝试加载的就是BootstrapClassLoader），所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法区元空间实现之jdk7和8字符串常量池、运行时常量池、静态变量到底在哪？</title>
    <link href="/2021/10/15/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%83%E7%A9%BA%E9%97%B4%E5%AE%9E%E7%8E%B0%E4%B9%8Bjdk7%E5%92%8C8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%B0%E5%BA%95%E5%9C%A8%E5%93%AA%EF%BC%9F/"/>
    <url>/2021/10/15/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%83%E7%A9%BA%E9%97%B4%E5%AE%9E%E7%8E%B0%E4%B9%8Bjdk7%E5%92%8C8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%88%B0%E5%BA%95%E5%9C%A8%E5%93%AA%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="方法区元空间实现之jdk7和8字符串常量池、运行时常量池、静态变量到底在哪？"><a href="#方法区元空间实现之jdk7和8字符串常量池、运行时常量池、静态变量到底在哪？" class="headerlink" title="方法区元空间实现之jdk7和8字符串常量池、运行时常量池、静态变量到底在哪？"></a>方法区元空间实现之jdk7和8字符串常量池、运行时常量池、静态变量到底在哪？</h1><p>回顾《深入理解Java虚拟机》时看到方法区有变化，记录一下。</p><p>转载自：<a href="https://blog.csdn.net/qq_43012792/article/details/107364084">https://blog.csdn.net/qq_43012792/article/details/107364084</a></p><p>方法区（落地实现jdk7永久代，jdk8元空间），元空间并不在虚拟机中，而是使用本地内存，它和堆在逻辑上是连续的，但在物理上是不连续的，所以也叫非堆。</p><h5 id="1、此区域是线程共享的。储存已加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据；"><a href="#1、此区域是线程共享的。储存已加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据；" class="headerlink" title="1、此区域是线程共享的。储存已加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据；"></a>1、此区域是线程共享的。储存已加载的类型信息、常量、静态变量、即时编译器编译后的代码等数据；</h5><h5 id="2、常量池：编译器生成的各种字面量和符号引用；"><a href="#2、常量池：编译器生成的各种字面量和符号引用；" class="headerlink" title="2、常量池：编译器生成的各种字面量和符号引用；"></a>2、常量池：编译器生成的各种字面量和符号引用；</h5><h5 id="3、关于字符串常量池和运行时常量池的位置说明："><a href="#3、关于字符串常量池和运行时常量池的位置说明：" class="headerlink" title="3、关于字符串常量池和运行时常量池的位置说明："></a>3、关于字符串常量池和运行时常量池的位置说明：</h5><table><thead><tr><th align="center">JDK版本</th><th align="center">方法区实现</th><th align="center">变化</th></tr></thead><tbody><tr><td align="center">jdk1.6</td><td align="center">永久代</td><td align="center">字符串常量池、运行时常量池、静态变量都是在永久代中</td></tr><tr><td align="center">jdk1.7</td><td align="center">永久代</td><td align="center">字符串常量池和静态变量被移动到了堆当中，运行时常量池还是在永久代中</td></tr><tr><td align="center">jdk1.8</td><td align="center">元空间</td><td align="center">字符串常量池和静态变量仍然在堆当中；运行时常量池、类型信息、常量、字段、方法被移动都了元空间中</td></tr></tbody></table><h5 id="4、元空间的好处："><a href="#4、元空间的好处：" class="headerlink" title="4、元空间的好处："></a>4、元空间的好处：</h5><p>① 减少报OOM的可能：元空间与永久代类似，本质区别是元空间并不占用虚拟机内存了，而是使用本地内存，由于本地内存一般是比较大的，所以方法区就没有那么容易报OOM（OutOfMemoryError）。<br>② 提高JVM性能：元空间的垃圾回收很少，一定程度上减少了GC扫描及压缩的时间。<br>③类及相关的元数据的生命周期与类加载器的一致；<br>④ 每个加载器有专门的存储空间。<br>元空间的对象被垃圾回收的概率相对堆空间的对象是要小很多的，所有将两者分开，就减少了很多去扫描元空间对象带来的开销。</p><h5 id="5、字符串常量池为什么要移动到堆空间中？"><a href="#5、字符串常量池为什么要移动到堆空间中？" class="headerlink" title="5、字符串常量池为什么要移动到堆空间中？"></a>5、字符串常量池为什么要移动到堆空间中？</h5><p>个人的理解：对于字符串常量这种创建完成用几次就不被使用的对象，是很容易被回收的。而要进行频繁垃圾回收的地方是堆空间， 这样在JDK7就把字符串常量池移动到堆空间中就是很明智和有必要的选择了。这样就避免了放到不频繁进行垃圾回收的元空间中应该被垃圾回收的对象而不能及时进行垃圾回收的浪费空间的现象出现。</p><p>思考：那么静态变量为什么也要在JDK7和字符串常量池一起移动到堆空间中呢？静态变量是不是和类一样的生命周期吗？</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP流量控制</title>
    <link href="/2021/08/16/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/08/16/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h1><p>又看了一遍《计算机网络-自顶向下方法》的传输层，感觉又有点模糊了，这里写下TCP流量控制的内容。</p><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>TCP流量控制和拥塞控制都是抑制发送方发送数据，但是它们是针对不同的原因采取的动作。那么为什么要进行流量控制呢？这个需要先了解TCP是怎么传输数据的，我们知道，TCP在两个客户端之间会维护一个缓冲池，从客户端A发送到客户端B的数据段会先发送到B的缓冲池，然后各个应用进程再从缓冲池里读取数据。</p><p><img src="https://pic.cloudfor.top/blog/image-20210816180127309.png" alt="image-20210816180127309"></p><h3 id="2、接收窗口"><a href="#2、接收窗口" class="headerlink" title="2、接收窗口"></a>2、接收窗口</h3><p>但是事情不会像我们想的那么完美的进行，客户端B可能有时候比较忙，可能不会那么及时的读取缓冲池里的数据，就像你给某人发消息，她/他可能要过一会儿才回你(doge)，可见世界的规律都是相通的。</p><p>那么问题来了，客户端B来不及处理接收的数据，另一边客户端A还在接着发，那万一A发的太快了，B的接收缓冲池满了怎么办，也就是缓冲池溢出了，所以需要想办法控制，可以让A知道B的缓冲池还剩多少空间，如果满了就不再发了。</p><p>于是TCP让发送方维护了一个接收窗口，表示接收方还有多少缓存空间，TCP又是全双工的，你可以给我发，我也可以给你发，所以两边都要维护一个接收窗口。</p><p>举个例子：</p><p>A向B发送一个文件，B为这个TCP连接分配了一个接收缓存，然后用 RevBuffer 表示缓存的大小。</p><p>再定义两个变量：</p><p>LastByteRead: 接收方B上的应用进程已经从缓存读取的数据流的最后一个字节的编号。</p><p>LastByteReve: 从网络到达的并且已经写入缓存的数据流的最后一个字节的编号。</p><p>要想缓存不溢出，就必须满足：</p><pre><code class="hljs java">LastByteReve  -  LastByteRead  &lt;=  RevBuffer</code></pre><p>也就是说留在缓存中的数据必须小于接收缓存的总容量。</p><p>我们再定义这样一个变量来表示接收窗口：</p><pre><code class="hljs java">rwnd = RevBuffer - (LastByteReve  -  LastByteRead)</code></pre><p>表示接收缓存还剩余的空间大小。这里直接用书里的一个图：</p><p><img src="https://pic.cloudfor.top/blog/image-20210817100852476.png" alt="image-20210817100852476"></p><p>那么具体的流量控制是怎么实现的呢？</p><p>其实是在B发送给A的报文段中定义了一个接收窗口字段，B给A发送报文段的时候把 rwnd 的值填进去，这样A就知道B的接收缓存还有多少空间，开始时 rwnd = RevBuffer。然后随着A给B发送数据，rwnd 的值会动态变化，这就需要B要一直监控之前定义的那两个变量（LastByteReve，LastByteRead）。</p><p>然后还不够，A也需要监控跟踪两个变量：LastByteSent 和 LastByteAcked</p><pre><code class="hljs java">LastByteSent - LastByteAcked = A发送到连接中，但是未被确认的数据量</code></pre><p> 只要A控制好未被确认的数据量的大小，不要超过 rwnd 的值，也就是不要超过B的接收缓存中的剩余空间大小，这样A就不会让B的接收缓存溢出了。用表达式来说就是：</p><pre><code class="hljs java">LastByteSent - LastByteAcked &lt;= rwnd</code></pre><p>但是，事情还没完，目前为止，我们已经实现了B的接收缓存空间不足时可以让A不再发数据，从而避免溢出，但是当B的应用进程不忙了，开始读取接收缓存的数据，并确认之后，B的接收缓存就又有新的空间了，那这时候怎么让A继续发数据呢？</p><p>TCP是这样处理的，TCP规范要求（以下摘抄的书中原话）：</p><p>当主机B的接收窗口为 0 的时，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，最终缓存将开始清空，并且确认报文里将包含一个非 0 的 rwnd 值。</p><p>这下就比较清楚了，就是在A被抑制发送数据后，依然会发一个基础的很小的报文段，用来监测B的接收窗口大小。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP的流量控制原理其实并不复杂，但是这些操作还是很妙的。顺带一提，UDP是没有流量控制的，毕竟连确认报文段都没有，要实现TCP的那些操作就不行，除非自己二次开发？</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习路径</title>
    <link href="/2021/06/05/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/06/05/Java%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java学习路径"><a href="#Java学习路径" class="headerlink" title="Java学习路径"></a>Java学习路径</h1><p>这个是个github的项目，不知道该学啥的时候看看这个。</p><p>javaGuide:</p><p><a href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a></p><p>然后是进阶的知识：</p><p><a href="https://github.com/doocs/advanced-java">https://github.com/doocs/advanced-java</a></p><p>后端架构师技术图谱：</p><p>从初级开发者到资深架构师所需要的所有知识点，不仅限于技术，还包含架构师素养、团队管理等综合知识。</p><p><a href="https://github.com/xingshaocheng/architect-awesome">https://github.com/xingshaocheng/architect-awesome</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/05/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="一、脏读、不可重复读、幻读"><a href="#一、脏读、不可重复读、幻读" class="headerlink" title="一、脏读、不可重复读、幻读"></a>一、脏读、不可重复读、幻读</h2><h3 id="1、脏读"><a href="#1、脏读" class="headerlink" title="1、脏读"></a>1、脏读</h3><p>在学习数据库事务的时候如果没有一些保护机制，我们很容易遇到一些 “奇怪” 的问题。</p><p>比如：</p><p>事务A对数据进行了修改，事务B读取了修改的数据，但是事务A由于某种原因没有提交，然后rollback, 这个时候事务B读取的数据就是<strong>脏数据</strong>。</p><p>这种读取到另一个事务未提交的数据的现象就是脏读(Dirty Read)。</p><p><img src="https://pic.cloudfor.top/blog/image-20210508112113251.png"></p><h3 id="2、不可重复读"><a href="#2、不可重复读" class="headerlink" title="2、不可重复读"></a>2、不可重复读</h3><p>事务B读取了两次数据源，在这个过程中事务A修改了数据源，导致事务B两次读取的数据不一致。</p><p>这种在同一个事务中，前后两次读取的数据不一致的现象就是不可重复读(Nonrepeatable Read)。</p><p><img src="https://pic.cloudfor.top/blog/image-20210508112421109.png"></p><h3 id="3、幻读"><a href="#3、幻读" class="headerlink" title="3、幻读"></a>3、幻读</h3><p>事务B两次读取数据，在这个过程中事务A增加了数据，导致事务B第二次读取出了第一次没有的行。</p><p>幻读强调的是集合的增减，而不是单条数据的更新。</p><p><img src="https://pic.cloudfor.top/blog/image-20210508113154676.png"></p><h3 id="4、第一类更新丢失"><a href="#4、第一类更新丢失" class="headerlink" title="4、第一类更新丢失"></a>4、第一类更新丢失</h3><p>事务A修改了数据，事务B也修改了数据，但是事务A没有提交，发生rollback, 把已经提交的事务B更新的数据覆盖掉了。</p><p><img src="https://pic.cloudfor.top/blog/image-20210508113701916.png"></p><h3 id="5、第二类更新丢失"><a href="#5、第二类更新丢失" class="headerlink" title="5、第二类更新丢失"></a>5、第二类更新丢失</h3><p>两个事务同时更新数据，但是事务B提交的数据把事务A提交的数据给覆盖掉了。</p><p><img src="https://pic.cloudfor.top/blog/image-20210508114013852.png"></p><h2 id="二、事务隔离级别"><a href="#二、事务隔离级别" class="headerlink" title="二、事务隔离级别"></a>二、事务隔离级别</h2><h3 id="1、ACID"><a href="#1、ACID" class="headerlink" title="1、ACID"></a>1、ACID</h3><p>说到数据库事务的隔离级别，不得不说下数据库事务的四大特性，即：<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistent）</strong>、<strong>隔离性（Isalotion）</strong>、**持久性(Durable)**，简称为<code>ACID</code></p><p><strong>原子性</strong>是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的<code>Redo/Undo</code>机制。</p><p><strong>一致性</strong>是指执行事务前后的状态要一致，可以理解为数据一致性。隔离性侧重指事务之间相互隔离，不受影响，这个与事务设置的隔离级别有密切的关系。</p><p><strong>持久性</strong>则是指在一个事务提交后，这个事务的状态会被持久化到数据库中，也就是事务提交，对数据的新增、更新将会持久化到数据库中。</p><p>原子性、隔离性、持久性都是为了保障一致性而存在的，一致性也是最终的目的。</p><h3 id="2、ACID原理"><a href="#2、ACID原理" class="headerlink" title="2、ACID原理"></a>2、ACID原理</h3><p> <strong>Redo/Undo</strong>机制将所有对数据的更新操作都写到日志中。</p><p>Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。</p><p>假如数据库在执行的过程中，不小心崩了，可以通过该日志的方式，回滚之前已经执行成功的操作，实现事务的一致性。</p><p>举一个场景，假如某个时刻数据库崩溃，在崩溃之前有事务A和事务B在执行，事务A已经提交，而事务B还未提交。当数据库重启进行 crash-recovery  时，就会通过Redo log将已经提交事务的更改写到数据文件，而还没有提交的就通过Undo log进行roll back。</p><h3 id="3、事务隔离级别"><a href="#3、事务隔离级别" class="headerlink" title="3、事务隔离级别"></a>3、事务隔离级别</h3><p>在Mysql中事务的隔离级别分为四大等级：</p><ul><li><p><strong>读未提交（READ UNCOMMITTED）、</strong></p></li><li><p><strong>读提交 （READ COMMITTED）、</strong></p></li><li><p><strong>可重复读 （REPEATABLE READ）、</strong></p></li><li><p><strong>串行化 （SERIALIZABLE）</strong></p></li></ul><p><strong>读未提交</strong>会读到另一个事务的未提交的数据，只能防止第一类更新丢失，会产生脏读问题。</p><p><strong>读提交</strong>则解决了脏读的问题，出现了不可重复读，即在一个事务任意时刻读到的数据可能不一样，可能会受到其它事务对数据修改提交后的影响，一般是对于update的操作。</p><p><img src="https://pic.cloudfor.top/blog/v2-b7eb34c0550d7cf0cb2a8f47013bac5a_1440w.jpg" alt="img"></p><p><strong>可重复读</strong>解决了之前不可重复读和脏读的问题，但是由带来了幻读的问题，幻读一般是针对inser操作。 例如：第一个事务查询一个User表id=100发现不存在该数据行，这时第二个事务又进来了，新增了一条id=100的数据行并且提交了事务。  这时第一个事务新增一条id=100的数据行会报主键冲突，第一个事务再select一下，发现id=100数据行已经存在，这就是<strong>幻读</strong>。除此之外，也能防止第二类更新丢失的问题。</p><p><strong>串行化</strong>，这是最高的隔离级别。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常不会用这个隔离级别。</p><p>这四大等级从上到下，隔离的效果是逐渐增强，但是性能却是越来越差。</p><h2 id="三、Mysql的锁机制"><a href="#三、Mysql的锁机制" class="headerlink" title="三、Mysql的锁机制"></a>三、Mysql的锁机制</h2><p>在Mysql中的锁可以分为<strong>共享锁</strong>/<strong>读锁</strong>（Shared Locks：允许多个事务同时读取同一行）、<strong>排他锁</strong>/<strong>写锁</strong>（Exclusive Locks：只要有写入就独占访问权限） 、<strong>间隙锁</strong>、<strong>行锁（Record Locks）</strong>、<strong>表锁</strong>。</p><h4 id="1、共享锁（S锁，读锁）："><a href="#1、共享锁（S锁，读锁）：" class="headerlink" title="1、共享锁（S锁，读锁）："></a>1、共享锁（S锁，读锁）：</h4><p>使用说明：若事务A对数据对象1加上S锁，则事务A可以读数据对象1但不能修改，其他事务只能再对数据对象1加S锁，而不能加X锁，直到事务A释放数据对象1上的S锁。这保证了其他事务可以读数据对象1，但在事务A释放数据对象1上的S锁之前不能对数据对象1做任何修改。</p><h4 id="2、排它锁（X锁，写锁）："><a href="#2、排它锁（X锁，写锁）：" class="headerlink" title="2、排它锁（X锁，写锁）："></a>2、排它锁（X锁，写锁）：</h4><p>使用说明：若事务A对数据对象1加上X锁，事务A可以读数据对象1也可以修改数据对象1，其他事务不能再对数据对象1加任何锁，直到事务A释放数据对象1上的锁。这保证了其他事务在事务A释放数据对象1上的锁之前不能再读取和修改数据对象1。</p><p> 在四个隔离级别中加锁肯定是要消耗性能的，而读未提交是没有加任何锁的，所以对于它来说也就是没有隔离的效果，所以它的性能也是最好的。</p><p>对于<strong>串行化</strong>加的是一把大锁，<strong>读的时候加共享锁，不能写，写的时候，加的是排它锁</strong>，阻塞其它事务的写入和读取，若是其它的事务长时间不能写入就会直接报超时，所以它的性能也是最差的，对于它来就没有什么并发性可言。</p><p>对于读提交和可重复读，他们俩的实现是兼顾解决数据问题，然后又要有一定的并发行，所以在实现上锁机制会比串行化优化很多，提高并发性，所以性能也会比较好。</p><h4 id="3、悲观锁和乐观锁"><a href="#3、悲观锁和乐观锁" class="headerlink" title="3、悲观锁和乐观锁"></a>3、悲观锁和乐观锁</h4><p>另外再顺便说下<strong>悲观锁</strong>和<strong>乐观锁</strong>。</p><h5 id="1、乐观锁："><a href="#1、乐观锁：" class="headerlink" title="1、乐观锁："></a>1、乐观锁：</h5><p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时(更新操作)，想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突了。</p><p>通常实现是这样的：在表中的数据进行操作时(更新)，先给数据表加一个版本(version)字段，每操作一次，将那条记录的版本号加1。也就是先查询出那条记录，获取出version字段,如果要对那条记录进行操作(更新),则先判断此刻version的值是否与刚刚查询出来时的version的值相等，如果相等，则说明这段期间，没有其他程序对其进行操作，则可以执行更新，将version字段的值加1；如果更新时发现此刻的version值与刚刚获取出来的version的值不相等，则说明这段期间已经有其他程序对其进行操作了，则不进行更新操作。</p><p><strong>优点</strong>：从上面的例子可以看出，乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统整体性能表现。<br><strong>缺点</strong>：乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，应该充分考虑到这些情况出现的可能性，并进行相应调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。<br><strong>总结</strong>：读用乐观锁，写用悲观锁。</p><h5 id="2、悲观锁："><a href="#2、悲观锁：" class="headerlink" title="2、悲观锁："></a>2、悲观锁：</h5><p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p><p>悲观锁的实现：首先实现悲观锁时，我们必须先使用set autocommit=0; 关闭mysql的autoCommit属性。因为我们查询出数据之后就要将该数据锁定。</p><p>悲观锁就是悲观主义者，它会认为我们在事务A中操作数据1的时候，一定会有事务B来修改数据1,所以，在第2步我们将数据查询出来后直接加上排它锁（X）锁，防止别的事务来修改事务1，直到我们commit后，才释放了排它锁。</p><p><strong>优点：</strong>保证了数据处理时的安全性。</p><p><strong>缺点：</strong>加锁造成了开销增加，并且增加了死锁的机会。降低了并发性。</p><h2 id="四、事务底层实现原理"><a href="#四、事务底层实现原理" class="headerlink" title="四、事务底层实现原理"></a>四、事务底层实现原理</h2><p>他们俩的底层实现采用的是MVCC（多版本并发控制）方式进行实现。（上面已经说了一部分，提供下其他视角）</p><p><strong>共享锁</strong>是针对同一份数据，多个读操作可以同时进行，简单来说即读加锁，不能写并且可并行读；</p><p><strong>排他锁</strong>针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞 。</p><p>而<strong>行锁</strong>和<strong>表锁</strong>，是从锁的粒度上进行划分的。</p><p><strong>行锁</strong>锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务 。</p><p>而<strong>表锁</strong>则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。</p><p><strong>间隙锁</strong>则分为两种：<code>Gap Locks</code>和<code>Next-Key Locks</code>。Gap Locks会锁住两个索引之间的区间，比如select * from User where id&gt;3 and id&lt;5 for update，就会在区间（3，5）之间加上Gap Locks。</p><p>Next-Key Locks是Gap Locks+Record Locks形成闭区间锁select * from User where  id&gt;=3 and id=&lt;5 for update，就会在区间[3,5]之间加上Next-Key Locks。</p><p> <strong>那Mysql中什么时候会加锁呢？</strong></p><p>在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁。</p><p><strong>MVCC（多版本并发控制）：</strong></p><p>在实现MVCC时用到了一致性视图，用于支持读提交和可重复读的实现。</p><p>在实现<strong>可重复读</strong>的隔离级别，只需要在事务开始的时候创建<strong>一致性视图</strong>，也叫做<strong>快照</strong>，之后的查询里都共用这个一致性视图，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读。</p><p>而读提交，每一个语句执行前都会重新计算出一个新的视图，这个也是可重复读和读提交在MVCC实现层面上的区别。</p><p><strong>快照（视图）在MVCC底层是怎么工作的？</strong></p><p>在InnoDB 中每一个事务都有一个自己的事务id，并且是唯一的，递增的 。</p><p> 对于Mysql中的每一个数据行都有可能存在多个版本，在每次事务更新数据的时候，都会生成一个新的数据版本，并且把自己的数据id赋值给当前版本的row trx_id。</p><p><img src="https://pic.cloudfor.top/blog/v2-a380bda8573a7de6597d9aa69f2a33c3_1440w.jpg" alt="img"></p><p>如图中所示，假如三个事务更新了同一行数据，那么就会有对应的三个数据版本。</p><p>实际上版本1、版本2并非实际物理存在的，而图中的U1和U2实际就是undo log，这v1和v2版本是根据当前v3和undo log计算出来的。</p><p><strong>那对于一个快照来说，你知道它要遵循什么规则吗？</strong></p><p>对于一个事务视图来说除了对自己更新的总是可见，另外还有三种情况：版本未提交的，都是不可见的；版本已经提交，但是是在创建视图之后提交的也是不可见的；版本已经提交，若是在创建视图之前提交的是可见的。</p><p> <strong>假如两个事务执行写操作，又怎么保证并发呢？</strong></p><p>假如事务1和事务2都要执行update操作，事务1先update数据行的时候，先会获取行锁，锁定数据，当事务2要进行update操作的时候，也会取获取该数据行的行锁，但是已经被事务1占有，事务2只能wait。</p><p>若是事务1长时间没有释放锁，事务2就会出现超时异常 。</p><p>这个是在update的where后的条件是在有索引的情况下， 若是没有索引的条件下，就获取所有行，都加上行锁，然后Mysql会再次过滤符合条件的的行并释放锁，只有符合条件的行才会继续持有锁。这样的性能消耗也会比较大。</p><p>参考：</p><p>脏读、不可重复读、幻读：</p><p><a href="https://www.zhihu.com/question/458275373/answer/1873975439">https://www.zhihu.com/question/458275373/answer/1873975439</a></p><p>我以为我对Mysql事务很熟，直到我遇到了阿里面试官：</p><p><a href="https://www.zhihu.com/question/458275373/answer/1873975439">https://www.zhihu.com/question/458275373/answer/1873975439</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>装箱拆箱</title>
    <link href="/2021/04/06/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
    <url>/2021/04/06/%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h1><p>参考：<a href="https://zhuanlan.zhihu.com/p/64004059">深入浅出了解“装箱与拆箱”! - 知乎 (zhihu.com)</a></p><p>Java中有8种基础数据类型，boolean,char,byte,short,int,long,float,double。从jdk5开始提供了自动装箱拆箱机制，对应的包装类型即Boolean，Character，Byte，Short，Integer，Long，Float，Double。</p><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>装箱就是将基础数据类型转换为对应的包装器类型；</p><p>拆箱就是将包装器类型转换为对应的基础数据类型；</p><h4 id="2、自动装箱（Autoboxing）"><a href="#2、自动装箱（Autoboxing）" class="headerlink" title="2、自动装箱（Autoboxing）"></a>2、自动装箱（Autoboxing）</h4><pre><code class="hljs java">Integer a = <span class="hljs-number">2</span>; <span class="hljs-comment">//Boxing</span></code></pre><p>简单的理解：将2装在一个箱子里，这个箱子的类型是Integer 。箱子这里面装的数值就是2，我们就完成了一次装箱操作。并把a指向2这个箱子。</p><pre><code class="hljs java">Integer b = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">2</span>);<span class="hljs-comment">//Boxing</span></code></pre><p>显示装箱。生成一个新的箱子 new Integer(); 并且这个箱子的值为2.而且让b指向这个箱子。</p><h4 id="3、拆箱（Unboxing）"><a href="#3、拆箱（Unboxing）" class="headerlink" title="3、拆箱（Unboxing）"></a>3、拆箱（Unboxing）</h4><p>故名思议就是将对象重新转化为基本数据类型</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> v = a.intValue(); <span class="hljs-comment">//Unboxing</span></code></pre><p>简单的理解：将里面int的值取出来。拆箱有个很典型的用法就是在进行运算的时候：因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。</p><p>例如：</p><pre><code class="hljs java">Integer c = <span class="hljs-number">5</span>;System.out.print(c--);<span class="hljs-comment">//进行计算时隐含的有自动拆箱</span></code></pre><h4 id="4、陷阱"><a href="#4、陷阱" class="headerlink" title="4、陷阱"></a>4、陷阱</h4><pre><code class="hljs java">System.out.println(Integer.valueOf(<span class="hljs-keyword">null</span>));</code></pre><p>Integer对象的值可以为null，所以编译器检查时不会出现检查时异常，但是在转换成int的时候就会抛出空指针异常。</p><h4 id="5、例题"><a href="#5、例题" class="headerlink" title="5、例题"></a>5、例题</h4><p><img src="https://pic.cloudfor.top/blog/v2-5768aefff626e82546bc2004c28a9900_1440w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问网站的过程</title>
    <link href="/2021/03/29/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/03/29/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="访问网站的过程"><a href="#访问网站的过程" class="headerlink" title="访问网站的过程"></a>访问网站的过程</h1><p>这个算是一个经典的问题了，这次总结一下。</p><p>参考：<a href="https://www.zhihu.com/question/20513729/answer/96332435">https://www.zhihu.com/question/20513729/answer/96332435</a></p><h4 id="1、Some-tips"><a href="#1、Some-tips" class="headerlink" title="1、Some tips:"></a>1、Some tips:</h4><p>DNS缓存:</p><p><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/</a></p><p>简单来说，一条域名的DNS记录会在本地有两种缓存：浏览器缓存和操作系统(OS)缓存。在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问DNS服务器(一般是ISP提供)，然后DNS服务器会递归式的查找域名记录，然后返回。</p><p>DNS记录会有一个ttl值(time to live)，单位是秒，意思是这个记录最大有效期是多少。经过实验，OS缓存会参考ttl值，但是不完全等于ttl值，而<strong>浏览器DNS缓存的时间跟ttl值无关，每种浏览器都使用一个固定值</strong>。</p><p><strong>在修改hosts文件后，所有OS中DNS缓存会被清空，而浏览器缓存则不发生变化。</strong></p><p><strong>Hosts</strong>是一个没有扩展名的<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/7581367">系统文件</a>，可以用记事本等工具打开，其作用就是将一些常用的网址<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D/86062">域名</a>与其对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>建立一个关联“<strong>数据库</strong>”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从<a href="https://baike.baidu.com/item/Hosts%E6%96%87%E4%BB%B6">Hosts文件</a>中寻找对应的<a href="https://baike.baidu.com/item/IP%E5%9C%B0%E5%9D%80">IP地址</a>，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">域名解析</a>服务器进行IP地址的解析。</p><p>操作系统规定，在进行DNS请求以前，先检查系自己的Hosts文件中是否有这个域名和IP的映射关系。如果有，则直接访问这个IP地址指定的网络位置，如果没有，再向已知的DNS服务器提出<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">域名解析</a>请求。也就是说Hosts的IP解析优先级比DNS要高。</p><h4 id="2、大体过程："><a href="#2、大体过程：" class="headerlink" title="2、大体过程："></a>2、大体过程：</h4><p>输入url后，浏览器会查找浏览器缓存，没有对应的ip就查找操作系统缓存，在\etc目录下（windows：c:\windows\system32\drivers\etc，linux: \etc）有一个hosts文件，包含一些常用域名和IP的映射。如果找到了对应的IP则进行下一步，没有找到则需要用 DNS 来获取IP。</p><blockquote><p>在DNS协议中，PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，得到就好，得不到还得向更高层次的DNS服务器求助，最终总能得到百度的IP。</p></blockquote><p>拿到IP之后，下一步是使用TCP协议，建立TCP连接。有关TCP 三次握手四次挥手下次专门写一篇。</p><p>不过，建立TCP连接有个前提（或者说给服务器发消息有个前提）：你必须能成功地把消息发到服务器上。虽然已经知道IP，但并无啥用（比如说，你在广东，你知道北京的地理坐标经纬度就能到北京了？你得知道有哪些路通往北京吧你得准备盘缠吧你得花时间吧）。</p><p>为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF等协议。</p><blockquote><p>我们都知道，你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地（你的PC）和目的地（服务器）；你的数据会经过一个又一个路由器，OSPF决定了会经过那些路由器（用一种叫路由算法的玩意，找出最佳路径）；从一个路由器怎么传给下一个路由器？这是ARP协议的JOB，ARP负责求下一个节点的地址（我们不止是要目的地，还要中间节点的地址）。<br>IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAP地址</p></blockquote><p>在建立了TCP连接之后，下一步就是用HTTP协议请求网页内容。</p><blockquote><p>你发个HTTP请求报文给服务器，如果服务器禁止你访问它就给你回个”Forbidden”，如果它暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK“并将你要的数据传给你；如果你还需要其它的东西再去跟它要（它一般还会给你的-_-）。</p></blockquote><p>收到了服务器的回复，是一坨HTML形式的文本。浏览器必须要能够理解文本的内容，并快速地渲染到屏幕上,渲染后就可以看到网页了。</p><p><img src="https://pic.cloudfor.top/blog/image-20210329140909739.png" alt="image-20210329140909739"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代码块详解</title>
    <link href="/2021/03/13/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/13/java%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="java静态代码块详解"><a href="#java静态代码块详解" class="headerlink" title="java静态代码块详解"></a>java静态代码块详解</h1><p>详细可以参考 <a href="https://blog.csdn.net/qq_35868412/article/details/89360250">https://blog.csdn.net/qq_35868412/article/details/89360250</a></p><p>执行顺序：</p><p><img src="https://pic.cloudfor.top/blog/image-20210313103346922.png" alt="image-20210313103346922"></p><p>左边是在父类执行main()方法，右边是在子类中执行。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>equals() 和 ==</title>
    <link href="/2021/03/10/equals()%E5%92%8C==/"/>
    <url>/2021/03/10/equals()%E5%92%8C==/</url>
    
    <content type="html"><![CDATA[<h1 id="equals-和"><a href="#equals-和" class="headerlink" title="equals() 和 =="></a>equals() 和 ==</h1><h4 id="1、基本数据类型"><a href="#1、基本数据类型" class="headerlink" title="1、基本数据类型"></a>1、基本数据类型</h4><p>对于基本数据类型来说，== 比较的是两者的值。如 int、byte、char、short、 long、float、double, boolean是转成int来存的，所以比较的是值。</p><h4 id="2、封装类"><a href="#2、封装类" class="headerlink" title="2、封装类"></a>2、封装类</h4><p>对于封装类，比如 String、Integer等这些类 == 比较的是对象的地址值.</p><p>而equals() 作为Object 类的方法，默认比较的也是对象的地址值，</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span> == obj);&#125;</code></pre><p>但是 String 等封装类重写了equals() 方法，所以最后比较的是两者的数据值，而不是地址。</p><p>String 重写的方法:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object anObject)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;        String anotherString = (String)anObject;        <span class="hljs-keyword">int</span> n = value.length;        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;            <span class="hljs-keyword">char</span> v1[] = value;            <span class="hljs-keyword">char</span> v2[] = anotherString.value;            <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (v1[i] != v2[i])                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;                i++;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</code></pre><p>但是并不是说所有的 == 和 equals() 比较的值都一定相等或一定不相等。</p><p>看下面这段代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span></span>&#123;        String str = <span class="hljs-string">&quot;2021-05-28&quot;</span>;        String str2 = <span class="hljs-string">&quot;2021-05-28&quot;</span>;        String str3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;2021-05-28&quot;</span>);        Integer a = <span class="hljs-number">127</span>;        Integer b = <span class="hljs-number">127</span>;        Integer c = <span class="hljs-number">128</span>;        Integer d = <span class="hljs-number">128</span>;        System.out.println(<span class="hljs-string">&quot;a==b? :&quot;</span> + (a == b));<span class="hljs-comment">//1</span>        System.out.println(<span class="hljs-string">&quot;c==d? :&quot;</span> + (c == d));<span class="hljs-comment">//2</span>        String addr = str.intern();        System.out.println(str == str2);<span class="hljs-comment">//3</span>        System.out.println(str == str3);<span class="hljs-comment">//4</span>        System.out.println(str.equals(str2));<span class="hljs-comment">//5</span>        System.out.println(addr);<span class="hljs-comment">//6</span>        System.out.println(<span class="hljs-string">&quot;a.addr:&quot;</span> + System.identityHashCode(a));<span class="hljs-comment">//7</span>        System.out.println(<span class="hljs-string">&quot;b.addr:&quot;</span> + System.identityHashCode(b));<span class="hljs-comment">//8</span>        System.out.println(<span class="hljs-string">&quot;c.addr:&quot;</span> + System.identityHashCode(c));<span class="hljs-comment">//9</span>        System.out.println(<span class="hljs-string">&quot;d.addr:&quot;</span> + System.identityHashCode(d));<span class="hljs-comment">//10</span>        System.out.println(<span class="hljs-string">&quot;str.addr:&quot;</span> + System.identityHashCode(str));<span class="hljs-comment">//11</span>        System.out.println(<span class="hljs-string">&quot;str2.addr:&quot;</span> + System.identityHashCode(str2));<span class="hljs-comment">//12</span>        System.out.println(<span class="hljs-string">&quot;str3.addr:&quot;</span> + System.identityHashCode(str3));<span class="hljs-comment">//13</span>    &#125;</code></pre><p>执行后的结果：</p><pre><code class="hljs java">a==b? :<span class="hljs-keyword">true</span><span class="hljs-comment">//1</span>c==d? :<span class="hljs-keyword">false</span><span class="hljs-comment">//2</span><span class="hljs-keyword">true</span><span class="hljs-comment">//3</span><span class="hljs-keyword">false</span><span class="hljs-comment">//4</span><span class="hljs-keyword">true</span><span class="hljs-comment">//5</span><span class="hljs-number">2021</span>-<span class="hljs-number">05</span>-<span class="hljs-number">28</span><span class="hljs-comment">//6</span>a.addr:<span class="hljs-number">1735600054</span><span class="hljs-comment">//7</span>b.addr:<span class="hljs-number">1735600054</span><span class="hljs-comment">//8</span>c.addr:<span class="hljs-number">21685669</span><span class="hljs-comment">//9</span>d.addr:<span class="hljs-number">2133927002</span><span class="hljs-comment">//10</span>str.addr:<span class="hljs-number">1836019240</span><span class="hljs-comment">//11</span>str2.addr:<span class="hljs-number">1836019240</span><span class="hljs-comment">//12</span>str3.addr:<span class="hljs-number">325040804</span><span class="hljs-comment">//13</span></code></pre><p>我们先来看第五条，str 和 str3 的值相等，所以 equals() 比较两者为 true,这符合我们的预期结果。</p><p>3：</p><p>既然说封装类 == 比较的是地址，那为什么 str 和 str2 == 比较的结果却是true 呢，原因就是这两个引用指向的是同一个对象。为什么？原因是为了减少或避免重复创建相同的对象，jdk有一个常量池，对于String 来说我们暂且称为 字符串常量池。在 str 被创建的时候这个字符串就被添加到了常量池。下次给对象用 == 赋值时，如果常量池中存在相同的字符串，那就直接把引用地址赋给新对象的引用，也就是 str2。所以两者指向的是同一个对象，同一个地址。</p><p>4：</p><p>那么为什么创建 str3 的时候赋的也是一样的值，但是 str == str3 的结果却为 false？因为用  new String(“2021-05-28”) 就重新创建了一个新的对象，而不是直接把常量池的对象引用赋给它。自然就不是同一个地址。</p><p>1：</p><p>知道上面的原因后，我们就大概可以知道为什么 a == b 为 true 了，也是常量池直接把引用赋给新对象引用。所以两个变量指向的是同一个对象，同一个地址。</p><p>2：</p><p>但是为什么同样的语句，c 和 d 就不行了？</p><p>因为 int 的常量池有个范围限制，总不可能把所有的数都放到常量池里，而这个范围上限就是 127，所以超过 127 的就会重新创建对象，重新分配地址。</p><p>6：</p><p>String.intern()方法就是看常量池中有没有相同的字符串，有就返回该字符串的引用，没有就添加新字符串到常量池。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h1><p>参考：<a href="https://www.zhihu.com/question/27125796/answer/1615074467">https://www.zhihu.com/question/27125796/answer/1615074467</a></p><p><a href="https://zhuanlan.zhihu.com/p/85624457">https://zhuanlan.zhihu.com/p/85624457</a></p><h4 id="一、简单工厂"><a href="#一、简单工厂" class="headerlink" title="一、简单工厂"></a>一、简单工厂</h4><p><img src="https://pic.cloudfor.top/blog/20210306111616.png"></p><p>简单工厂并没有在23种设计模式之中。</p><p><strong>缺点：</strong></p><p>简单工厂模式中的工厂是一个具体的类，而非接口或者抽象类，用switch-case 或者 if - else 来判断并返回对象实例。如果增加新的产品，就要增加新的 if-else, 这种方法扩展性比较差。违背了开闭原则，也影响了可读性。所以，这种方式使用在业务较简单，工厂类不会经常更改的情况。</p><h4 id="二、工厂方法"><a href="#二、工厂方法" class="headerlink" title="二、工厂方法"></a>二、工厂方法</h4><p>为了解决上面提到的”增加if-else”的问题，可以为每一个产品子类建立一个对应的工厂子类，这些工厂子类实现同一个抽象工厂接口。这样，创建不同的产品，只需要实现不同的工厂子类。当有产品加入时，新建具体工厂继承抽象工厂，而不用修改任何一个类。</p><p><img src="https://pic.cloudfor.top/blog/image-20210313165601761.png" alt="image-20210313165601761"></p><pre><code class="hljs java"><span class="hljs-comment">// 苹果工厂</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();    &#125;&#125;<span class="hljs-comment">// 梨子工厂</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PearFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear();    &#125;&#125;<span class="hljs-comment">// 调用者</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;        AppleFactory appleFactory = <span class="hljs-keyword">new</span> AppleFactory();        Fruit apple = appleFactory.create();        PearFactory pearFactory = <span class="hljs-keyword">new</span> PearFactory();        Fruit pear = pearFactory.create();        apple.eat();        pear.eat();    &#125;&#125;</code></pre><p><strong>优点：</strong></p><p>调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。</p><ul><li>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。</li><li>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</li></ul><p><strong>缺点：</strong></p><p>每一种产品对应一个工厂子类，在创建具体产品对象时，实例化不同的工厂子类。但是，如果业务涉及的子类越来越多，难道每一个子类都要对应一个工厂类吗？这样会使得系统中类的个数成倍增加，增加了代码的复杂度。</p><h4 id="三、抽象工厂"><a href="#三、抽象工厂" class="headerlink" title="三、抽象工厂"></a>三、抽象工厂</h4><p>工厂方法模式可以进一步优化，提取出工厂接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span> </span>&#123;    <span class="hljs-function">Fruit <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>然后苹果工厂和梨子工厂都实现此接口：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Apple();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PearFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Fruit <span class="hljs-title">create</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Pear();    &#125;&#125;</code></pre><p>此时，调用者可以将 AppleFactory 和 PearFactory 统一作为 IFactory 对象使用，调用者 Java 代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;        IFactory appleFactory = <span class="hljs-keyword">new</span> AppleFactory();        Fruit apple = appleFactory.create();        IFactory pearFactory = <span class="hljs-keyword">new</span> PearFactory();        Fruit pear = pearFactory.create();        apple.eat();        pear.eat();    &#125;&#125;</code></pre><p>可以看到，我们在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p><p>由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。</p><p>例如：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;        IFactory factory = <span class="hljs-keyword">new</span> AppleFactory();        Fruit fruit = factory.create();        fruit.eat();    &#125;&#125;</code></pre><p>如果需要替换为吃梨子，只需要更改一行代码即可：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;        IFactory factory = <span class="hljs-keyword">new</span> PearFactory();        Fruit fruit = factory.create();        fruit.eat();    &#125;&#125;</code></pre><p>IFactory 中只有一个抽象方法时，或许还看不出抽象工厂模式的威力。实际上抽象工厂模式主要用于替换一系列方法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使用抽象方法模式的话，只需在 IFactory 接口中定义好增删改查四个方法，让 SQLFactory 和 AccessFactory 实现此接口，调用时直接使用 IFactory 中的抽象方法即可，调用者无需知道使用的什么数据库，我们就可以非常方便的整个替换程序的数据库，并且让客户端毫不知情。</p><p>抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p><p>类似这种把产品类分组，组内不同产品由同一工厂类的不同方法实现的设计模式，就是抽象工厂模式。</p><p>抽象工厂适用于以下情况：</p><ol><li>一个系统要独立于它的产品的创建、组合和表示时；</li><li>一个系统要由多个产品系列中的一个来配置时；</li><li>要强调一系列相关的产品对象的设计以便进行联合使用时；</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时；</li></ol><ul><li>抽象工厂：声明了创建抽象产品对象的操作接口。</li><li>具体产品工厂：实现了抽象工厂的接口，负责创建产品对象。</li><li>产品抽象类或接口：定义一类产品对象的接口。</li><li>具体产品实现：定义一个将被相应具体工厂创建的产品对象。</li></ul><p><strong>总结：</strong></p><p>简单工厂：唯一工厂类，一个产品抽象类，工厂类的创建方法依据入参判断并创建具体产品对象。</p><p>工厂方法：多个工厂类，一个产品抽象类，利用多态创建不同的产品对象，避免了大量的if-else判断。</p><p>抽象工厂：多个工厂类，多个产品抽象类，产品子类分组，同一个工厂实现类创建同组中的不同产品，减少了工厂子类的数量。</p><p>在下述情况下可以考虑使用工厂模式：</p><ol><li>在编码时不能预见需要创建哪种类的实例。</li><li>系统不应依赖于产品类实例如何被创建、组合和表达的细节。</li></ol><p>总之，工厂模式就是为了方便创建同一接口定义的具有复杂参数和初始化步骤的不同对象。工厂模式一般用来创建复杂对象。只需用new就可以创建成功的简单对象，无需使用工厂模式，否则会增加系统的复杂度。</p><p>此外，如果对象的参数是不固定的，推荐使用Builder模式。</p><p>在实际项目中，结合Spring中的InitializingBean接口，可以利用@Autowired注解优雅的实现工厂。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h5 id="1、开闭原则："><a href="#1、开闭原则：" class="headerlink" title="1、开闭原则："></a>1、开闭原则：</h5><p>​    一个软件实体如类、模块和函数应该对修改封闭，对扩展开放。</p><h5 id="2、单一职责原则："><a href="#2、单一职责原则：" class="headerlink" title="2、单一职责原则："></a>2、单一职责原则：</h5><p>​    一个类只做一件事，一个类应该只有一个引起它修改的原因。</p><h5 id="3、里氏替换原则："><a href="#3、里氏替换原则：" class="headerlink" title="3、里氏替换原则："></a>3、里氏替换原则：</h5><p>​    子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</p><h5 id="4、依赖倒置原则："><a href="#4、依赖倒置原则：" class="headerlink" title="4、依赖倒置原则："></a>4、依赖倒置原则：</h5><p>​    细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由    低层的实现层来完成。</p><h5 id="5、迪米特法则："><a href="#5、迪米特法则：" class="headerlink" title="5、迪米特法则："></a>5、迪米特法则：</h5><p>​    又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友话。</p><h5 id="6、接口隔离原则："><a href="#6、接口隔离原则：" class="headerlink" title="6、接口隔离原则："></a>6、接口隔离原则：</h5><p>​    客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口    拆分，让实现类只需依赖自己需要的接口方法。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap和HashTable</title>
    <link href="/2021/03/01/HashMap%E5%92%8CHashTable/"/>
    <url>/2021/03/01/HashMap%E5%92%8CHashTable/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h1><p>这里总结下两者的区别。部分内容参考自：</p><p><a href="https://www.zhihu.com/search?q=hashmap%E5%92%8Chashtable&amp;utm_content=search_suggestion&amp;type=content">https://www.zhihu.com/search?q=hashmap%E5%92%8Chashtable&amp;utm_content=search_suggestion&amp;type=content</a></p><p>1、HashMap 是线程不安全的，在多线程下容易产生死循环。但是在单线程下效率较高。Hashtable线程安全的，很多方法都有synchronized修饰，但同时因为加锁导致单线程环境下效率较低。</p><p>2、HashMap允许有一个key为null，允许多个value为null；而Hashtable不允许key或者value为null。</p><p>然后讲下源码实现上的一些区别吧。</p><h4 id="1、构造函数的比较"><a href="#1、构造函数的比较" class="headerlink" title="1、构造函数的比较"></a>1、构造函数的比较</h4><p>HashMap：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +                                           initialCapacity);    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +                                           loadFactor);    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);&#125;​<span class="hljs-comment">//该方法返回大于等于cap的最小2次幂的整数</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;&#125;</code></pre><p>HashMap的底层数组大小必须为2^n，主要是为了后面数据量大时减小hash冲突。</p><p>Hashtable：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Load: &quot;</span>+loadFactor);​    <span class="hljs-keyword">if</span> (initialCapacity==<span class="hljs-number">0</span>)        initialCapacity = <span class="hljs-number">1</span>;    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;    table = <span class="hljs-keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];    threshold = (<span class="hljs-keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="hljs-number">1</span>);&#125;​<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-number">11</span>, <span class="hljs-number">0.75f</span>);&#125;</code></pre><p>Hashtable的长度可以是任意值，导致当底层数组长度为合数的时候，Hashtable的hash算法散射不均匀，容易产生hash冲突。所以，可以清楚的看到Hashtable的默认构造函数底层数组长度为11（质数）。原因可以看看这篇</p><p><a href="https://blog.csdn.net/zhishengqianjun/article/details/79087525?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;dist_request_id=743237a1-2185-4f92-b696-4f3fd31e1746&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control">https://blog.csdn.net/zhishengqianjun/article/details/79087525?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control&amp;dist_request_id=743237a1-2185-4f92-b696-4f3fd31e1746&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.control</a></p><h4 id="2、hash算法的区别"><a href="#2、hash算法的区别" class="headerlink" title="2、hash算法的区别"></a>2、hash算法的区别</h4><p>关于扰动函数详细可看这篇：<a href="https://www.zhihu.com/question/20733617">https://www.zhihu.com/question/20733617</a></p><p>HashMap：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;    <span class="hljs-keyword">int</span> h;    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);&#125;<span class="hljs-comment">//手写的，源码在不存在这一句，但是原理是类似的，详情可以去看putVal方法</span><span class="hljs-keyword">int</span> i = (table.length-<span class="hljs-number">1</span>) &amp; hash(key)</code></pre><p>putVal方法相关源码：</p><pre><code class="hljs java">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)    n = (tab = resize()).length;<span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);</code></pre><p>hash算法将 key 的 hash 值散射到数组中，</p><p>1、合数2^n转换为2进制的数之后，最高位为1其余的位数都为0，比如16–&gt;10000，32–&gt;100000。那么，2^n-1转换为2进制后，所有的bit位都为1，比如31–&gt;11111，127–&gt;1111111。所以，hashcode与（2^n-1）做&amp;运算每一个bit位都可以保持原来的值。</p><p>2、当hash()方法得到的值&lt;=（table.length-1）,其运算结果就在[0,table.length-1]范围内均匀散射。当hash()方法得到的值小于table.length-1的时候，运算结果就是该方法的原值。当hash()方法得到的值等于table.length-1的的时候，运算结果为0。</p><p>3、当hash()得到的值&gt;(table.length-1)，此时table.length-1为较小的数，所以&amp;运算的结果还是在[0,table.length-1]之间。具体实现是这样的，table.length-1转化为2进制的数之后位数小于hash()方法得到的2进制数，所以它的高位只能用0去补齐，又由于&amp;运算的特性，只要有一个为0那么都为0，所以此时相当于转化为情况1。</p><p>总结下就是在数组较小的时候，key 的 hash 值相对数组长度值来说较大，进行按位与操作时，数组的二进制会在前面补 0，然后操作结果实际上舍弃了hash值的高位部分。</p><p>在数组越来越大之后，补的0也相应减少，所以总能够刚刚好匹配散射进数组。</p><p>Hashtable：</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> hash = key.hashCode();<span class="hljs-comment">//0x7FFFFFFF转换为10进制之后是Intger.MAX_VALUE,也就是2^31 - 1</span><span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;</code></pre><p>可以看出Hashtable的hash算法首先使得hash的值小于等于整型数的最大值，再通过%运算实现均匀散射。</p><p>由于计算机是底层的运算是基于2进制的，所以HashMap的hash算法使用&amp;运算代替%运算，在运算速度上明显HashMap的hash算法更优。</p><h4 id="3、扩容的机制的区别"><a href="#3、扩容的机制的区别" class="headerlink" title="3、扩容的机制的区别"></a>3、扩容的机制的区别</h4><p>扩容的等后面再写</p><h4 id="4、结构的区别"><a href="#4、结构的区别" class="headerlink" title="4、结构的区别"></a>4、结构的区别</h4><p>hashMap在jdk1.8之后采用了数组+链表+红黑树的结构，它规定在链表长度大于 8 的时候就讲链表转为红黑树，在小于 6 的时候变回链表。</p><p>Hashtable则还是原来的数组+链表结构。</p><p>以看出到jdk1.8 HashMap和Hashtable的区别越来越大，HashMap相较与之前的jdk做了很多的优化，最重要的是在内部实现结构上引进了红黑数还有扩容上的优化。Hashtable作为jdk1.2遗留下来的类，到jdk1.8没有大改，<strong>所以对数据的一致性要求较低的话可以使用ConcurrentHashMap来替代Hashtable</strong></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2 Ubuntu18.04 DNS 问题（apt-get update失败）</title>
    <link href="/2021/01/10/WSL2%20Ubuntu18.04%20DNS%20%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/10/WSL2%20Ubuntu18.04%20DNS%20%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL2-Ubuntu18-04-DNS-问题（apt-get-update失败）"><a href="#WSL2-Ubuntu18-04-DNS-问题（apt-get-update失败）" class="headerlink" title="WSL2 Ubuntu18.04 DNS 问题（apt-get update失败）"></a>WSL2 Ubuntu18.04 DNS 问题（apt-get update失败）</h1><p>安装WSL2 ubuntu之后老是遇到 update 时连接不到服务器，而且有时 ssh 连接一些服务器也连不上，后来查了下是 DNS 问题。网上也有一些教程，但是还是遇到了一些新的坑。</p><p>一般临时解决方案：</p><p>更改 namesever </p><pre><code class="hljs shell">sudo vim /etc/resolv.conf</code></pre><p>然后把 nameserver 改成 8.8.8.8 或者其他可用的也行</p><pre><code class="hljs shell">:wq</code></pre><p>保存。</p><p>这下去更新应该就可以了。</p><p>但是，重新打开一个窗口或者重启之后就又失效了，原因是 windows 每次会自动更改 namesever </p><p>要长期有效，需要新建一个 wsl.conf 文件</p><pre><code class="hljs shell">sudo vim /etc/wsl.conf</code></pre><p>然后添加内容：</p><pre><code class="hljs shell">[network]generateResolvConf = false</code></pre><p>再保存，就可以了。</p><p>一般就没问题了，但是我后面还遇到了一点问题，我是先改了wsl.conf文件，但是更改resolv.conf文件的时候老是提示</p><pre><code class="hljs shell">E166:Can&#x27;t open linked file for writing</code></pre><p>就一直保存不了，然后查了下，说这是个符号链接，但是也没有给出解决方案。</p><p>我想到之前符号链接文件是可以直接删除的，而且这个文件里没有其他内容，于是我就直接把这个文件删除了，又重新用 vim 新建了一个文件，再把 nameserver 改了就好了。我怀疑有可能是之前新建文件的时候命令打错了，新建成了链接文件。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4B ubuntu18.04 安装Docker</title>
    <link href="/2021/01/10/%E6%A0%91%E8%8E%93%E6%B4%BE4B%20ubuntu18.04%20%E5%AE%89%E8%A3%85Docker/"/>
    <url>/2021/01/10/%E6%A0%91%E8%8E%93%E6%B4%BE4B%20ubuntu18.04%20%E5%AE%89%E8%A3%85Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派4B-ubuntu18-04-安装Docker与卸载"><a href="#树莓派4B-ubuntu18-04-安装Docker与卸载" class="headerlink" title="树莓派4B ubuntu18.04 安装Docker与卸载"></a>树莓派4B ubuntu18.04 安装Docker与卸载</h1><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1、更换软件源"><a href="#1、更换软件源" class="headerlink" title="1、更换软件源"></a>1、更换软件源</h3><p>如果已经更换过可以跳过，没有更换的话下载很慢，最好换成国内源</p><h3 id="2、安装需要的包"><a href="#2、安装需要的包" class="headerlink" title="2、安装需要的包"></a>2、安装需要的包</h3><pre><code class="hljs shell">sudo apt install apt-transport-https ca-certificates software-properties-common curl</code></pre><h3 id="3、添加-GPG-密钥，并添加-Docker-ce-软件源"><a href="#3、添加-GPG-密钥，并添加-Docker-ce-软件源" class="headerlink" title="3、添加 GPG 密钥，并添加 Docker-ce 软件源"></a>3、添加 GPG 密钥，并添加 Docker-ce 软件源</h3><p>这里添加中科大的 Docker-ce 源，添加 GPG 密钥：</p><pre><code class="hljs shell">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></pre><p>安装上即可，一般不需要验证</p><p>添加 Docker-ce 源：</p><pre><code class="hljs shell">sudo add-apt-repository &quot;deb [arch=arm64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code></pre><p>树莓派是ARM架构的，所以在添加源时应当指定参数：arch=arm64</p><h3 id="4、然后更新软件包"><a href="#4、然后更新软件包" class="headerlink" title="4、然后更新软件包"></a>4、然后更新软件包</h3><pre><code class="hljs shel">sudo apt update</code></pre><h3 id="5、安装-Docker"><a href="#5、安装-Docker" class="headerlink" title="5、安装 Docker"></a>5、安装 Docker</h3><pre><code class="hljs shell">sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><h3 id="6、验证"><a href="#6、验证" class="headerlink" title="6、验证"></a>6、验证</h3><pre><code class="hljs shell">docker info</code></pre><h3 id="7、设置开机自启动并启动-Docker-ce（安装成功后默认已设置并启动，可忽略）"><a href="#7、设置开机自启动并启动-Docker-ce（安装成功后默认已设置并启动，可忽略）" class="headerlink" title="7、设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）"></a>7、设置开机自启动并启动 Docker-ce（安装成功后默认已设置并启动，可忽略）</h3><pre><code class="hljs shell">sudo systemctl enable dockersudo systemctl start docker</code></pre><h3 id="8、测试运行"><a href="#8、测试运行" class="headerlink" title="8、测试运行"></a>8、测试运行</h3><pre><code class="hljs shell">sudo docker run hello-world</code></pre><h3 id="9、运行命令"><a href="#9、运行命令" class="headerlink" title="9、运行命令"></a>9、运行命令</h3><pre><code class="hljs shell">docker run --name nextcloud   -p 81:80   -v /usbu/program/docker/volumes:/var/lib/docker/volumes  -d nextcloud</code></pre><p>:前是宿主机文件夹，后面是容器共享文件夹</p><h3 id="10、添加当前用户到-docker-用户组，可以不用-sudo-运行-docker（可选）"><a href="#10、添加当前用户到-docker-用户组，可以不用-sudo-运行-docker（可选）" class="headerlink" title="10、添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）"></a>10、添加当前用户到 docker 用户组，可以不用 sudo 运行 docker（可选）</h3><pre><code class="hljs shell">sudo groupadd dockersudo usermod -aG docker $USER</code></pre><h3 id="11、测试添加用户组（可选）"><a href="#11、测试添加用户组（可选）" class="headerlink" title="11、测试添加用户组（可选）"></a>11、测试添加用户组（可选）</h3><pre><code class="hljs shell">docker run hello-world</code></pre><h2 id="二、卸载"><a href="#二、卸载" class="headerlink" title="二、卸载"></a>二、卸载</h2><h3 id="1、运行以下命令以停止所有正在运行的容器并删除所有docker对象："><a href="#1、运行以下命令以停止所有正在运行的容器并删除所有docker对象：" class="headerlink" title="1、运行以下命令以停止所有正在运行的容器并删除所有docker对象："></a>1、运行以下命令以停止所有正在运行的容器并删除所有docker对象：</h3><pre><code class="hljs shel">docker container stop $(docker container ls -aq)docker system prune -a --volumes</code></pre><h4 id="2、删除某软件-及其安装时自动安装的所有包"><a href="#2、删除某软件-及其安装时自动安装的所有包" class="headerlink" title="2、删除某软件,及其安装时自动安装的所有包"></a>2、删除某软件,及其安装时自动安装的所有包</h4><pre><code class="hljs shell">sudo apt-get autoremove docker docker-ce docker-engine  docker.io  containerd runc</code></pre><h4 id="3、删除docker其他没有没有卸载"><a href="#3、删除docker其他没有没有卸载" class="headerlink" title="3、删除docker其他没有没有卸载"></a>3、删除docker其他没有没有卸载</h4><pre><code class="hljs shel">dpkg -l | grep docker</code></pre><h4 id="4、卸载没有删除的docker相关插件-结合自己电脑的实际情况"><a href="#4、卸载没有删除的docker相关插件-结合自己电脑的实际情况" class="headerlink" title="4、卸载没有删除的docker相关插件(结合自己电脑的实际情况)"></a>4、卸载没有删除的docker相关插件(结合自己电脑的实际情况)</h4><pre><code class="hljs shell">sudo apt-get autoremove docker-ce-*</code></pre><h4 id="5、删除docker的相关配置-amp-目录"><a href="#5、删除docker的相关配置-amp-目录" class="headerlink" title="5、删除docker的相关配置&amp;目录"></a>5、删除docker的相关配置&amp;目录</h4><pre><code class="hljs shell">sudo rm -rf /etc/systemd/system/docker.service.dsudo rm -rf /var/lib/docker</code></pre><h4 id="6、确定docker卸载完毕"><a href="#6、确定docker卸载完毕" class="headerlink" title="6、确定docker卸载完毕"></a>6、确定docker卸载完毕</h4><pre><code class="hljs shell">docker --version</code></pre><h2 id="三、更改docker存储目录"><a href="#三、更改docker存储目录" class="headerlink" title="三、更改docker存储目录"></a>三、更改docker存储目录</h2><h4 id="1、先停止docker-服务"><a href="#1、先停止docker-服务" class="headerlink" title="1、先停止docker 服务"></a>1、先停止docker 服务</h4><pre><code class="hljs shell">systemctl stop docker</code></pre><h4 id="2、修改配置文件"><a href="#2、修改配置文件" class="headerlink" title="2、修改配置文件"></a>2、修改配置文件</h4><pre><code class="hljs shell">vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --graph /mnt/sde/docker</code></pre><p>在最后加上：</p><pre><code class="hljs shell">--graph /mnt/sde/docker</code></pre><p>/mnt/sde/docker 就是新目录</p><h4 id="3、重新载入配置"><a href="#3、重新载入配置" class="headerlink" title="3、重新载入配置"></a>3、重新载入配置</h4><pre><code class="hljs shell">systemctl daemon-reload</code></pre><h4 id="4、重启服务"><a href="#4、重启服务" class="headerlink" title="4、重启服务"></a>4、重启服务</h4><pre><code class="hljs shell">systemctl start docker</code></pre><h4 id="5、验证配置"><a href="#5、验证配置" class="headerlink" title="5、验证配置"></a>5、验证配置</h4><pre><code class="hljs shell">docker info</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu18.04服务器安装MySql</title>
    <link href="/2021/01/07/Ubuntu18.04%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySql/"/>
    <url>/2021/01/07/Ubuntu18.04%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySql/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu18-04服务器安装MySql"><a href="#Ubuntu18-04服务器安装MySql" class="headerlink" title="Ubuntu18.04服务器安装MySql"></a>Ubuntu18.04服务器安装MySql</h1><p>这里用的是阿里云的ECS</p><h3 id="1、安装mysql"><a href="#1、安装mysql" class="headerlink" title="1、安装mysql"></a>1、安装mysql</h3><pre><code class="hljs powershell">sudo apt<span class="hljs-literal">-get</span> install mysql<span class="hljs-literal">-server</span></code></pre><p>如果需要客户端继续装mysql-client</p><p>检查mysql状态：</p><pre><code class="hljs shell">service mysql status</code></pre><p><img src="https://pic.cloudfor.top/blog/image-20210107145719759.png" alt="image-20210107145719759"></p><p>看到前面的小绿点说明正常运行</p><p>如果没有运行，可执行以下命令启动：</p><pre><code class="hljs she">sudo service mysql start</code></pre><p>相应的，停止则执行：</p><pre><code class="hljs she">sudo service mysql stop</code></pre><p>重启服务：</p><pre><code class="hljs shel">sudo service mysql restart</code></pre><h3 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h3><h5 id="1、修改密码"><a href="#1、修改密码" class="headerlink" title="1、修改密码"></a>1、修改密码</h5><p>在安装过程中我们并没有遇到设置密码的请求，可以查看mysql的初始密码，用来登陆mysql：</p><pre><code class="hljs shel">sudo cat &#x2F;etc&#x2F;mysql&#x2F;debian.cnf</code></pre><p><img src="https://pic.cloudfor.top/blog/image-20210107150340850.png" alt="image-20210107150340850"></p><p>然后登陆mysql：</p><pre><code class="hljs shel">sudo mysql -u root -p</code></pre><p>可能会要求先输入 root 用户密码，再输入刚才的mysql默认密码进行登陆。</p><p>然后在MySQL中修改密码，执行：</p><pre><code class="hljs shel">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;</code></pre><p>后面一个 root 就是新密码。</p><p>PS：没有找到初始密码直接执行命令：sudo mysql你会发现直接进入MySQL了，当然该命令只有第一次有效，改了密码之后就没用了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>动手实操</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树小结</title>
    <link href="/2021/01/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B0%8F%E7%BB%93/"/>
    <url>/2021/01/06/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="红黑树小结"><a href="#红黑树小结" class="headerlink" title="红黑树小结"></a>红黑树小结</h1><p>[部分摘抄自敖丙的文章<a href="https://www.zhihu.com/question/312327402">https://www.zhihu.com/question/312327402</a> ]另一篇 ：<a href="https://zhuanlan.zhihu.com/p/95892351">https://zhuanlan.zhihu.com/p/95892351</a> 两篇都有遗漏的地方，结合起来差不多。</p><p>红黑树和2-3-4 树是一个套路，可以互相转化。</p><h4 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h4><p>2-3-4树是<strong>阶数</strong>为4的B树，B树，全名BalanceTree，平衡树。这种结构主要用来做查找。关于2-3-4树插入和删除另外专门写一篇总结下，对 2-3 树来说，大体就是2节点插入会优先变3节点，3节点会临时变 4 节点，然后4节点变成一个父节点带两个子节点。</p><p><img src="https://pic.cloudfor.top/blog/image-20210113110205366.png" alt="image-20210113110205366"></p><h4 id="2-3-4树到红黑树的转化"><a href="#2-3-4树到红黑树的转化" class="headerlink" title="2-3-4树到红黑树的转化"></a>2-3-4树到红黑树的转化</h4><p>总的来说，红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p><p>2-3-4树中的2节点对应着红黑树中的黑色节点，而2-3-4树中的非2节点是以<strong>红节点+黑节点</strong>的方式存在，红节点的意义是与黑色父节点结合，表达着2-3-4树中的3，4节点。</p><p><img src="https://pic.cloudfor.top/blog/image-20210113110701595.png" alt="image-20210113110701595"></p><h5 id="整棵树的转化："><a href="#整棵树的转化：" class="headerlink" title="整棵树的转化："></a>整棵树的转化：</h5><p><img src="https://pic.cloudfor.top/blog/image-20210113110939314.png" alt="image-20210113110939314"></p><h3 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h3><p>1、每个节点，要么是黑色，要么是红色</p><p>2、根节点是黑色</p><p>3、每个叶子结点都是黑色的空结点 （NIL节点）</p><p>4、每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)</p><p>5、从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo + 码云Gitee搭建图床</title>
    <link href="/2021/01/05/PicGo%20+%20%E7%A0%81%E4%BA%91Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/01/05/PicGo%20+%20%E7%A0%81%E4%BA%91Gitee%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo-码云Gitee搭建图床"><a href="#PicGo-码云Gitee搭建图床" class="headerlink" title="PicGo + 码云Gitee搭建图床"></a>PicGo + 码云Gitee搭建图床</h1><p>放 Github 上速度慢不说，老是莫名其妙就变成一个小图标打不开。自己的图床又没多少图片，专门买个对象存储之类的又没必要，想来想去还是放 Gitee 上。毕竟白嫖。。。</p><h3 id="1、安装PicGo-和-Gitee-插件"><a href="#1、安装PicGo-和-Gitee-插件" class="headerlink" title="1、安装PicGo 和 Gitee 插件"></a>1、安装PicGo 和 Gitee 插件</h3><p>先安装好好 picGo ，下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>然后安装插件：</p><p><img src="https://pic.cloudfor.top/blog/%E5%9B%BE%E5%BA%8A1.png" alt="图床1"></p><p>安装之后可以看到 gitee：</p><p><img src="https://pic.cloudfor.top/blog/%E5%9B%BE%E5%BA%8A2.png" alt="图床2"></p><h3 id="2、在Gitee新建一个仓库"><a href="#2、在Gitee新建一个仓库" class="headerlink" title="2、在Gitee新建一个仓库"></a>2、在Gitee新建一个仓库</h3><p>没有Gitee账号的先注册一个，然后新建一个仓库</p><p><img src="https://pic.cloudfor.top/blog/Gitee%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.png" alt="Gitee新建仓库1"></p><p>名字自己随便起一个就行了，选择 公开，并且勾选 使用Readme文件初始化这个仓库</p><p><img src="https://pic.cloudfor.top/blog/gitee%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%932.png" alt="gitee新建仓库2"></p><h3 id="3、配置PicGo"><a href="#3、配置PicGo" class="headerlink" title="3、配置PicGo"></a>3、配置PicGo</h3><p>配置如下：</p><p><img src="https://pic.cloudfor.top/blog/picGo%E9%85%8D%E7%BD%AE1.png" alt="picGo配置1"></p><p>用户名和仓库名可以直接复制浏览器 url 链接中的部分。</p><p>私人令牌去gitee 获取：</p><p><img src="https://pic.cloudfor.top/blog/%E5%9B%BE%E5%BA%8Agitee%E4%BB%A4%E7%89%8C1.png" alt="图床gitee令牌1"></p><p><img src="https://pic.cloudfor.top/blog/%E5%9B%BE%E5%BA%8Agitee%E7%A7%81%E4%BA%BA%E4%BB%A4%E7%89%8C2.png" alt="图床gitee私人令牌2"></p><p>然后会弹出你的令牌，只会在这个地方<strong>显示一次</strong>，以后都看不到，所以要保管好。</p><p>然后点确定并且设为默认图床。就可以上传图片了，速度还是挺快的。</p><p><img src="https://pic.cloudfor.top/blog/image-20210105114133319.png" alt="image-20210105114133319"></p><p>除此之外，可以配合一些 markdown 编辑器使用，达到直接复制到编辑器就直接自动上传图片的效果，比如Typora 编辑器。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>动手实操</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识点-深拷贝和浅拷贝</title>
    <link href="/2020/12/30/Java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/12/30/Java%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Java知识点-深拷贝和浅拷贝"><a href="#Java知识点-深拷贝和浅拷贝" class="headerlink" title="Java知识点-深拷贝和浅拷贝"></a>Java知识点-深拷贝和浅拷贝</h1><h3 id="1-克隆"><a href="#1-克隆" class="headerlink" title="1.克隆"></a>1.<em>克隆</em></h3><p>在实际编程过程中，我们常常要遇到这种情况：</p><p>有一个对象A，在某一时刻A中已经包含了一些有效值，此时可能 会需要一个和A完全相同新对象B，并且此后对B任何改动都不会影响到A中的值，也就是说，A与B是两个独立的对象，但B的初始值是由A对象确定的。在 Java语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现clone（）方法是其中最简单，也是最高效的手段。 </p><p>Java的所有类都默认继承java.lang.Object类，在java.lang.Object类中有一个方法clone()。JDK API的说明文档解释这个方法将返回Object对象的一个拷贝。</p><p>要说明的有两点：一是拷贝对象返回的是一个新对象，而不是一个引用。二是拷贝对象与用 new操作符返回的新对象的区别就是这个拷贝已经包含了一些原来对象的信息，而不是对象的初始信息。</p><h3 id="2-深拷贝与浅拷贝"><a href="#2-深拷贝与浅拷贝" class="headerlink" title="2.深拷贝与浅拷贝"></a>2.<em>深拷贝与浅拷贝</em></h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。</p><p>举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。</p><p>浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。</p><p>深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树和平衡二叉树</title>
    <link href="/2020/12/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/12/05/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树和平衡二叉树"><a href="#二叉搜索树和平衡二叉树" class="headerlink" title="二叉搜索树和平衡二叉树"></a>二叉搜索树和平衡二叉树</h1><p>虽然之前看过二叉树的，但是时间久了还是容易模糊，所以这里继续记录一下。而且主要是看到一篇非常形象好理解的博客，所以这里转载一下，自己做个保存。</p><p>原文链接：<a href="https://blog.csdn.net/qq_25940921/article/details/82183093">https://blog.csdn.net/qq_25940921/article/details/82183093</a></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>　　二叉查找树，也称二叉搜索树，或二叉排序树。其定义也比较简单，要么是一颗空树，要么就是具有如下性质的二叉树：</p><p>（1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>（2） 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p><p>（3） 任意节点的左、右子树也分别为二叉查找树；</p><p>（4） 没有键值相等的节点。</p><p><img src="https://pic.cloudfor.top/blog/KFnUASyHam9idBe.png" alt="img"></p><p>如上图所示，是不同形态的二叉查找树。二叉查找树是对要查找的数据进行生成树，左支的值小于右支的值。在查找的时候也是一样的思路，从根节点开始，比节点大进入右支，比节点小进入左支，直到查找到目标值。</p><p>　　二叉查找树的插入算法比较简单：空树，就首先生成根节点；不是空树就按照查找的算法，找到父节点，然后作为叶子节点插入，如果值已经存在就插入失败。</p><p>　　删除操作稍微复杂一点，有如下几种情况：</p><p> （1）如果删除的是叶节点，可以直接删除；</p><p> （2）如果被删除的元素有一个子节点，可以将子节点直接移到被删除元素的位置；</p><p> （3）如果有两个子节点，这时候就采用中序遍历，找到待删除的节点的后继节点，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除。如下图：</p><p><img src="https://pic.cloudfor.top/blog/mqac19Lg5nQVIOD.png" alt="image-20201205164030082"></p><p>将待删除节点与后继节点互换，变成如下图所示：</p><p><img src="https://pic.cloudfor.top/blog/Y6lyC4A2aveMD5Q.png" alt="image-20201205165616516"></p><p>将待删除元素删除，如下图所示：</p><p><img src="https://pic.cloudfor.top/blog/CbRF1gywjDhGNrm.png" alt="image-20201205165647271"></p><p>另外，二叉查找树还有一个性质，即<strong>对二叉查找树进行中序遍历，即可得到有序的数列。</strong></p><p>　　二叉查找树的查询复杂度，和二分查找一样，插入和查找的时间复杂度均为 O(logn) ，但是在最坏的情况下仍然会有 O(n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（如上不同形态的二叉树图中的b）。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>　　平衡二叉搜索树，又被称为AVL树，且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong> —-来自百度百科</p><p>　　由于普通的二叉查找树会容易失去”平衡“，极端情况下，二叉查找树会退化成线性的链表，导致插入和查找的复杂度下降到 O(n) ，所以，这也是平衡二叉树设计的初衷。那么平衡二叉树如何保持”平衡“呢？根据定义，有两个重点，一是左右两子树的高度差的绝对值不能超过1，二是左右两子树也是一颗平衡二叉树。</p><p>　　如下图所示，左图是一棵平衡二叉树，根节点10，左右两子树的高度差是1，而右图，虽然根节点左右两子树高度差是0，但是右子树15的左右子树高度差为2，不符合定义，所以右图不是一棵平衡二叉树。</p><p><img src="https://pic.cloudfor.top/blog/EmVkD6l4MxeCAIH.png" alt="image-20201205165758268"></p><p>由此可以看出平衡二叉树是一棵高度平衡的二叉查找树。所以，要构建跟维系一棵平衡二叉树就比普通的二叉树要复杂的多。在构建一棵平衡二叉树的过程中，当有新的节点要插入时，检查是否因插入后而破坏了树的平衡，如果是，则需要做旋转去改变树的结构。</p><p>　　关于旋转，这东西不拿动态图将还真很难讲明白。所以我就借一下 <a href="https://blog.csdn.net/sun_tttt/article/details/65445754">最容易懂得红黑树</a> 这篇文章中左旋右旋的图来讲。</p><p> <strong>左旋</strong>：</p><p><img src="https://pic.cloudfor.top/blog/HtmRgJGCSq4Mkjz.gif" alt="左旋"></p><p><strong>右旋</strong>：</p><p><img src="https://pic.cloudfor.top/blog/RJaT1LlOso9xGrc.gif" alt="右旋"></p><p>不同于顺时针跟逆时针变换这种方式去记忆，上面两个动态图特别方便记忆跟理解：</p><p>　　<strong>左旋就是将节点的右支往左拉，右子节点变成父节点，并把晋升之后多余的左子节点出让给降级节点的右子节点；</strong></p><p>　　<strong>而右旋就是反过来，将节点的左支往右拉，左子节点变成了父节点，并把晋升之后多余的右子节点出让给降级节点的左子节点。</strong></p><p>　　<strong>即左旋就是往左变换，右旋就是往右变换。</strong>不管是左旋还是右旋，旋转的目的都是<strong>将节点多的一支出让节点给另一个节点少的一支</strong>。</p><p>　　举个例子，像上图是否平衡二叉树的图里面，左图在没插入前”19“节点前，该树还是平衡二叉树，但是在插入”19“后，导致了”15“的左右子树失去了”平衡“，所以此时可以将”15“节点进行左旋，让”15“自身把节点出让给”17“作为”17“的左树，使得”17“节点左右子树平衡，而”15“节点没有子树，左右也平衡了。如下图，</p><p><img src="https://pic.cloudfor.top/blog/DTqPaSQ4frCXJyN.png" alt="image-20201205170026045"></p><p>由于在构建平衡二叉树的时候，当有<strong>新节点插入</strong>时，都会判断插入后时候平衡，这说明了插入新节点前，都是平衡的，也即高度差绝对值不会超过1。当新节点插入后，有可能会有导致树不平衡，这时候就需要进行调整，而可能出现的情况就有4种，分别称作<strong>左左，左右，右左，右右</strong>。</p><p><strong>左左</strong>：</p><p><img src="https://pic.cloudfor.top/blog/6g1y7xAHQutwqk4.png" alt="image-20201205170102008"></p><p>左左即为在原来平衡的二叉树上，在节点的左子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”10“节点的左子树”7“，的左子树”4“，插入了节点”5“或”3“导致失衡。</p><p>　　左左调整其实比较简单，只需要对节点进行右旋即可，如下图，对节点”10“进行右旋，</p><p>　　注意：如果对左右旋变换还不是很懂或不是很熟练的，可以对照着前面的那两个动图去想象，自己动手变换几次，就明白了。</p><p><img src="https://pic.cloudfor.top/blog/ohVw9Znm4xlbStN.png" alt="image-20201205170211537"></p><p><strong>左右</strong>：</p><p><img src="https://pic.cloudfor.top/blog/9BYk6CqoFsriyh7.png" alt="image-20201205170256122"></p><p>左右即为在原来平衡的二叉树上，在节点的左子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的左子树”7“，的右子树”9“，插入了节点”10“或”8“导致失衡。</p><p>　　左右的调整就不能像左左一样，进行一次旋转就完成调整。我们不妨先试着让左右像左左一样对”11“节点进行右旋，结果图如下，右图的二叉树依然不平衡，而右图就是接下来要讲的右左，即左右跟右左互为镜像，左左跟右右也互为镜像。</p><p><img src="https://pic.cloudfor.top/blog/CcseN1OY3GHkuaL.png" alt="image-20201205170343470"></p><p><strong>右右跟左左一样，只需要旋转一次就能把树调整平衡，而左右跟右左也一样，都要进行旋转两次才能把树调整平衡</strong>，所以，首先上图的这种调整是错误的，正确的调整方式是，将左右进行第一次旋转，将左右先调整成左左，然后再对左左进行调整，从而使得二叉树平衡。</p><p>　　即先对上图的节点”7“进行左旋，使得二叉树变成了左左，之后再对”11“节点进行右旋，此时二叉树就调整完成，如下图，</p><p><img src="https://pic.cloudfor.top/blog/DSsq3UgfRcAVbj5.png" alt="image-20201205170418373"></p><p><strong>右左</strong>：</p><p><img src="https://pic.cloudfor.top/blog/9Bl1xXWQasONyeu.png" alt="image-20201205170456817"></p><p>右左即为在原来平衡的二叉树上，在节点的右子树的左子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的右子树”15“，的左子树”13“，插入了节点”12“或”14“导致失衡。</p><p>　　前面也说了，右左跟左右其实互为镜像，所以调整过程就反过来，先对节点”15“进行右旋，使得二叉树变成右右，之后再对”11“节点进行左旋，此时二叉树就调整完成，如下图，</p><p><img src="https://pic.cloudfor.top/blog/5jixoMl3efBb7nW.png" alt="image-20201205170522548"></p><p><strong>右右</strong>：</p><p><img src="https://pic.cloudfor.top/blog/hHfPa9wKxGRSYnm.png" alt="image-20201205170559188"></p><p>右右即为在原来平衡的二叉树上，在节点的右子树的右子树下，有新节点插入，导致节点的左右子树的高度差为2，如上即为”11“节点的右子树”13“，的左子树”15“，插入了节点”14“或”19“导致失衡。</p><p>　　右右只需对节点进行一次左旋即可调整平衡，如下图，对”11“节点进行左旋。</p><p><img src="https://pic.cloudfor.top/blog/eTaNyrdnDUIqt5Q.png" alt="image-20201205170632008"></p><p>平衡二叉树构建的过程，就是节点插入的过程，插入失衡情况就上面4种，算简单了，下面讲下<strong>平衡二叉树节点的删除</strong>，删除的情况会复杂一点，复杂的原因主要在于删除了节点之后要维系二叉树的平衡，但是删除二叉树节点总结起来就两个判断：<strong>①删除的是什么类型的节点？②删除了节点之后是否导致失衡？</strong></p><p>　　节点的类型有三种：1.叶子节点；2.只有左子树或只有右子树；3.既有左子树又有右子树。</p><p>　　针对这三种节点类型，再引入判断②，所以<strong>处理思路</strong>分别是：</p><p>（1）当删除的节点是叶子节点，则将节点删除，然后从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，此时到根节点还发现没有失衡，则说此时树是平衡的；如果中间过程发现失衡，则判断属于哪种类型的失衡（左左，左右，右左，右右），然后进行调整。</p><p>（2）删除的节点只有左子树或只有右子树，这种情况其实就比删除叶子节点的步骤多一步，就是将节点删除，然后把仅有一支的左子树或右子树替代原有结点的位置，后面的步骤就一样了，从父节点开始，判断是否失衡，如果没有失衡，则再判断父节点的父节点是否失衡，直到根节点，如果中间过程发现失衡，则根据失衡的类型进行调整。</p><p>（3）删除的节点既有左子树又有右子树，这种情况又比上面这种多一步，就是中序遍历，找到待删除节点的前驱或者后驱都行，然后与待删除节点互换位置，然后把待删除的节点删掉，后面的步骤也是一样，判断是否失衡，然后根据失衡类型进行调整。</p><p>　　最后总结一下，平衡二叉树是一棵高度平衡的二叉树，所以<strong>查询的时间复杂度是 O(logN)</strong> 。<strong>插入</strong>的话上面也说，失衡的情况有4种，左左，左右，右左，右右，即一旦插入新节点导致失衡需要调整，<strong>最多也只要旋转2次</strong>，所以，<strong>插入复杂度是 O(1)</strong> ，但是平衡二叉树也不是完美的，也有<strong>缺点</strong>，从上面删除处理思路中也可以看到，就是<strong>删除节点时有可能因为失衡，导致需要从删除节点的父节点开始，不断的回溯到根节点，如果这棵平衡二叉树很高的话，那中间就要判断很多个节点</strong>。所以后来也出现了综合性能比其更好的树—-<strong>红黑树</strong>，后面再讲。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>数据结构和算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键-Windows</title>
    <link href="/2020/12/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE-Windows/"/>
    <url>/2020/12/02/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE-Windows/</url>
    
    <content type="html"><![CDATA[<h1 id="IDEA快捷键-Windows"><a href="#IDEA快捷键-Windows" class="headerlink" title="IDEA快捷键-Windows"></a>IDEA快捷键-Windows</h1><h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th><strong>快捷键</strong></th><th><strong>介绍</strong></th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 <code>（必备）</code></td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 <code>（必备）</code></td></tr><tr><td>Ctrl + Z</td><td>撤销 <code>（必备）</code></td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 <code>（必备）</code></td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td></tr><tr><td>Ctrl + W</td><td>递进式选择代码块。选中光标所在的单词或段落，连续按可在选中基础上扩展选中范围 <code>（必备）</code></td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表</td></tr><tr><td>Ctrl + N</td><td>根据输入的 <strong>类名</strong> 查找类文件</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + J</td><td>插入自定义动态代码模板</td></tr><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + U</td><td>前往当前光标所在的方法的父类的方法 / 接口定义</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义出，等效于 <code>Ctrl + 左键单击</code></td></tr><tr><td>Ctrl + K</td><td>版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + T</td><td>版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td>Ctrl + H</td><td>显示当前类的层次结构</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl + -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F1</td><td>在光标所在的错误代码出显示错误信息</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F11</td><td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td>Ctrl + Enter</td><td>智能分隔行</td></tr><tr><td>Ctrl + End</td><td>跳到文件尾</td></tr><tr><td>Ctrl + Home</td><td>跳到文件头</td></tr><tr><td>Ctrl + Space</td><td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl + 逗号</code> <code>（必备）</code></td></tr><tr><td>Ctrl + Delete</td><td>删除光标后面的单词或是中文句</td></tr><tr><td>Ctrl + BackSpace</td><td>删除光标前面的单词或是中文句</td></tr><tr><td>Ctrl + 1,2,3…9</td><td>定位到对应数值的书签位置</td></tr><tr><td>Ctrl + 左键单击</td><td>在打开的文件标题上，弹出该文件路径</td></tr><tr><td>Ctrl + 光标定位</td><td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td>Ctrl + 左方向键</td><td>光标跳转到当前单词 / 中文句的左侧开头位置</td></tr><tr><td>Ctrl + 右方向键</td><td>光标跳转到当前单词 / 中文句的右侧开头位置</td></tr><tr><td>Ctrl + 前方向键</td><td>等效于鼠标滚轮向前效果</td></tr><tr><td>Ctrl + 后方向键</td><td>等效于鼠标滚轮向后效果</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10 Anaconda环境pythona安装配置chromedriver</title>
    <link href="/2020/11/27/win10%20Anaconda%E7%8E%AF%E5%A2%83pythona%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEchromedriver/"/>
    <url>/2020/11/27/win10%20Anaconda%E7%8E%AF%E5%A2%83pythona%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEchromedriver/</url>
    
    <content type="html"><![CDATA[<h1 id="win10-Anaconda环境pythona安装配置chromedriver"><a href="#win10-Anaconda环境pythona安装配置chromedriver" class="headerlink" title="win10 Anaconda环境pythona安装配置chromedriver"></a>win10 Anaconda环境pythona安装配置chromedriver</h1><p>​        因为之前写爬虫的时候遇到个坑，跟chromedriver有关，但是搜索错误的话完全搜索不到，后面自己找到的问题，在这记录一下。</p><h2 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h2><p>一开始我一直以为Anaconda里是有chromedriver的，这也就导致问题。写完代码后直接报错：</p><pre><code class="hljs python">hp, ht, pid, tid = _winapi.CreateProcess(executable, args, PermissionError:[WinError <span class="hljs-number">5</span>] Acess denied</code></pre><p>或者：</p><pre><code class="hljs python">hp, ht, pid, tid = _winapi.CreateProcess(executable, args, PermissionError:[WinError <span class="hljs-number">5</span>]拒绝访问</code></pre><p>都是一个意思。</p><p>然后百度找了很多，都是说python权限不够，给它加完全控制的权限，结果加了还是不行，一番搜索无果后突然搜到一篇怎么安装chromedriver的博客，我就想到不会是根本没有玩意儿吧。。。</p><h2 id="2、下载chromedriver"><a href="#2、下载chromedriver" class="headerlink" title="2、下载chromedriver"></a>2、下载chromedriver</h2><p>于是我去下载了和我chrome浏览器版本一致的chromedriver,但是观望那个进得去，下载页面却进不去。。。</p><p>然后又找到另一个资源的地址，进去也是打不开下载链接，好不容易进了资源页面，下载不了，然后用迅雷给下下来了，不得不说有时候迅雷有奇效。</p><p>后面找到两个地址：</p><p><em><a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a></em></p><p><a href="https://npm.taobao.org/mirrors/chromedriver/">https://npm.taobao.org/mirrors/chromedriver/</a></p><p>第一个就是谷歌的，应该直接进是进不去的，第二个是淘宝的镜像地址，应该可以下，不过因为我之前是用迅雷下的，所以还没试过第二个地址有没有问题。</p><h2 id="3、配置chromedriver"><a href="#3、配置chromedriver" class="headerlink" title="3、配置chromedriver"></a>3、配置chromedriver</h2><p>下载好之后，还需要配置一下。</p><p>1、把下载的文件解压到谷歌浏览器安装目录的根目录</p><p>如果装在C盘的一般是：</p><p>C:\Users\mi\AppData\Local\Google\Chrome\Application</p><p>直接在桌面右键谷歌浏览器图标就可以进入。不过我改到D盘了。</p><p>2、然后把这个路径添加到环境变量。</p><p><img src="https://pic.cloudfor.top/blog/xhOclNfvP5dwtzR.png" alt="image-20201127100555202"></p><p>3、把解压出来的chromedriver复制一份到Anaconda3根目录就可以了，接着在代码中导入selenium然后就可以直接使用:</p><pre><code class="hljs python">browser = webdriver.Chrome(options=chrome_options)</code></pre><p>获取到chromdriver</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>采坑日记</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识点-JVM(一)</title>
    <link href="/2020/11/24/Java%E7%9F%A5%E8%AF%86%E7%82%B9-JVM%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/11/24/Java%E7%9F%A5%E8%AF%86%E7%82%B9-JVM%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Java知识点-JVM-一"><a href="#Java知识点-JVM-一" class="headerlink" title="Java知识点-JVM(一)"></a>Java知识点-JVM(一)</h1><h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><ol><li>程序运行过程</li><li>类的加载过程</li><li>垃圾回收器（JVM垃圾回收机制，四个垃圾回收算法，垃圾回收器的分类和使用场景）</li><li>运行时数据区（虚拟机栈、本地方法栈、程序计数器、方法区、堆）</li><li>JVM调优（常用调优方式和工具，常用参数，）</li></ol><h2 id="一、程序运行过程"><a href="#一、程序运行过程" class="headerlink" title="一、程序运行过程"></a>一、程序运行过程</h2><ol><li>先把java代码编译成字节码，也就是吧.java文件编译成.class文件，这个过程的大致执行流程：java源代码-&gt;词法分析-&gt;语法分析-&gt;语义分析-&gt;字节码生成。其实也就是编译原理的那些东西和流程，其中任何一个节点失败就会造成编译失败。</li><li>把 .class文件放到java虚拟机，这个虚拟机通常指Oracle官方自带的Hotspot JVM；</li><li>java虚拟机使用类加载器（Class Loader）装载class文件。</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后JVM会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是<strong>解释执行</strong>的，JVM对此作了优化，比如对于Hotspot虚拟机来说，它本身提供了JIT(Just In Time)也就是我们通常说的动态编译，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了<strong>编译执行</strong>。</li></ol><h2 id="二、类的加载过程（和上一点有些重复）"><a href="#二、类的加载过程（和上一点有些重复）" class="headerlink" title="二、类的加载过程（和上一点有些重复）"></a>二、类的加载过程（和上一点有些重复）</h2><ol><li>加载：根据查找路径找到相应的 class文件然后导入。</li><li>检查：检查加载的class 文件的正确性。</li><li>准备：给类中的静态变量和静态代码块分配内存。</li><li>解析：虚拟机将常量池中的符号引用换成直接引用。符号引用可以理解为一个标识，而直接引用直接指向内存中的地址。</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ol><h2 id="三、垃圾回收机制"><a href="#三、垃圾回收机制" class="headerlink" title="三、垃圾回收机制"></a>三、垃圾回收机制</h2><h3 id="1、如何确定某个对象是需要被回收的？"><a href="#1、如何确定某个对象是需要被回收的？" class="headerlink" title="1、如何确定某个对象是需要被回收的？"></a>1、如何确定某个对象是需要被回收的？</h3><p>JVM中主要有两种方法判定，一个是引用计数器，另一个是可达性分析。</p><p><strong>引用计数器：</strong>为每个对象创建一个引用计数，有对象引用时计数器+1，引用被释放时计数器-1，当引用计数器为0是就可以回收。但是这个方法的缺点是不能解决循环引用的问题。</p><p><strong>可达性分析：</strong>这个方法是通过一系列的“GC Roots”对象作为起点，从起点开始往下搜索，搜索过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以回收的。不过这个对象至少要经历两次标记过程才会真的变成可回收对象。</p><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><p>主要有以下四种垃圾回收算法，</p><h4 id="2-1-标记-清除算法（Mark-Sweep）"><a href="#2-1-标记-清除算法（Mark-Sweep）" class="headerlink" title="2.1 标记-清除算法（Mark-Sweep）"></a>2.1 标记-清除算法（Mark-Sweep）</h4><p>这是最基础的垃圾回收算法，最简单也最容易实现。主要分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占空间。标记-清除算法的缺点就是回收之后的的内存区域比较分散，不连续。</p><p>回收之前：</p><p><img src="https://pic.cloudfor.top/blog/pKHRyu2iWCbegds.png" alt="标记清除"></p><p>回收之后：</p><p><img src="https://pic.cloudfor.top/blog/dqhnBj679fcpwoJ.png" alt="标记清除"></p><h4 id="2-2-复制算法（Copying）"><a href="#2-2-复制算法（Copying）" class="headerlink" title="2.2 复制算法（Copying）"></a>2.2 复制算法（Copying）</h4><p>为了解决标记-清除算法的缺陷，出现了复制算法，它将可用内存an容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就讲还存活的对象复制到另一块上，然后再把当前这块使用的内存一次清理回收，这样就不会出现内存碎片的问题了。但是复制算法的缺点在于内存移动消耗太大。</p><p>回收之前：</p><p><img src="https://pic.cloudfor.top/blog/OD1sL5a9khYWTHx.png" alt="img"></p><p>回收之后：</p><p><img src="https://pic.cloudfor.top/blog/nUiAWTq3tEdyeGV.png" alt="img"></p><h4 id="2-3-标记-整理算法（Mark-Compact）"><a href="#2-3-标记-整理算法（Mark-Compact）" class="headerlink" title="2.3 标记-整理算法（Mark-Compact）"></a>2.3 标记-整理算法（Mark-Compact）</h4><p>为了解决复制算法的问题，提出了标记整理算法。它也是分为两个阶段，第一个阶段是标记，但是在标记完之后不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理边界以外的内存。</p><p>回收之前：</p><p><img src="https://pic.cloudfor.top/blog/lxdEhkTMJrDvVF5.png" alt="img"></p><p>回收之后：</p><p><img src="https://pic.cloudfor.top/blog/S2AOyRHvK8sVr6P.png" alt="img"></p><h4 id="2-4-分代收集（Generational-Collection）"><a href="#2-4-分代收集（Generational-Collection）" class="headerlink" title="2.4 分代收集（Generational Collection）"></a>2.4 分代收集（Generational Collection）</h4><p>分代收集是目前大部分JVM的垃圾回收器采用的算法。它是根据对象的生命周期不同划分为若干个不同的区域，一般分为老生代和新生代，老生代每次只有少量对象被回收，新生代则有大量对象被回收。这样就可以根据不同代的特点采取最合适的收集算法。新生代一般用复制算法，新生代又分为Eden区域和 from survivor、以及to survivor区域，他们默认占比是8:1:1，每次垃圾回收时，</p><ol><li>把Eden和from survivor中存活的对象放入 to survivor区；</li><li>清空Eden和from survivor区；</li><li>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</li></ol><p>每次在from survivor 到 to survivor移动时都存活的对象，年龄就+1，当年龄达到15（默认值），就升级为老生代。大对象会直接进入老生代。</p><p>老生代当空间占用达到某个值之后就会触发全局垃圾回收，一般使用标记-整理算法，以上循环往复。</p><h3 id="3-典型的垃圾回收器"><a href="#3-典型的垃圾回收器" class="headerlink" title="3.典型的垃圾回收器"></a>3.典型的垃圾回收器</h3><h4 id="3-1-Serial-Serial-Old"><a href="#3-1-Serial-Serial-Old" class="headerlink" title="3.1 Serial/Serial Old"></a>3.1 Serial/Serial Old</h4><p>Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。</p><h4 id="3-2-ParNew"><a href="#3-2-ParNew" class="headerlink" title="3.2 ParNew"></a>3.2 ParNew</h4><p>ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。</p><h4 id="3-3-Parallel-Scavenge"><a href="#3-3-Parallel-Scavenge" class="headerlink" title="3.3 Parallel Scavenge"></a>3.3 Parallel Scavenge</h4><p>Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。</p><h4 id="3-4-Parallel-Old"><a href="#3-4-Parallel-Old" class="headerlink" title="3.4 Parallel Old"></a>3.4 Parallel Old</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。</p><h4 id="3-5-CMS"><a href="#3-5-CMS" class="headerlink" title="3.5 CMS"></a>3.5 CMS</h4><p>CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。</p><h4 id="3-6-G1"><a href="#3-6-G1" class="headerlink" title="3.6 G1"></a>3.6 G1</h4><p>G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。</p><p>四、运行时数据区</p><p>五、JVM调优</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2020/11/24/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/24/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><h2 id="一、文件、目录操作命令"><a href="#一、文件、目录操作命令" class="headerlink" title="一、文件、目录操作命令"></a>一、文件、目录操作命令</h2><h4 id="1、ls命令"><a href="#1、ls命令" class="headerlink" title="1、ls命令"></a>1、ls命令</h4><p>功能：显示文件和目录的信息<br>ls　以默认方式显示当前目录文件列表<br>ls -a 显示所有文件包括隐藏文件<br>ls -l 显示文件属性，包括大小，日期，符号连接，是否可读写及是否可执行<br>ls -lh 显示文件的大小，以容易理解的格式印出文件大小 (例如 1K 234M 2G)<br>ls -lt 显示文件，按照修改时间排序<br> ls -F 在列出的文件名和目录名后添加标志。例如，在可执行文件后添加“*”，在目录名后添加“/”以区分不同的类型。</p><h4 id="2、cd命令"><a href="#2、cd命令" class="headerlink" title="2、cd命令"></a>2、cd命令</h4><p>功能：进入目录<br>cd dir　切换到当前目录下的dir目录<br>cd /　切换到根目录<br>cd ..　切换到到上一级目录<br>cd ../..　切换到上二级目录<br>cd ~　切换到用户目录，比如是root用户，则切换到/root下</p><h4 id="3、cp命令"><a href="#3、cp命令" class="headerlink" title="3、cp命令"></a>3、cp命令</h4><p>功能：copy文件<br>cp source target　将文件source复制为target<br>cp /root /source .　将/root下的文件source复制到当前目录<br>cp –av soure_dir target_dir　将整个目录复制，两目录完全一样</p><h4 id="4、rm命令"><a href="#4、rm命令" class="headerlink" title="4、rm命令"></a>4、rm命令</h4><p>功能：删除文件或目录<br>rm file　删除某一个文件<br>rm -f file 删除时候不进行提示。可以于r参数（递归删除）配合使用<br>rm -rf dir　删除当前目录下叫dir的整个目录</p><h4 id="5、mv命令"><a href="#5、mv命令" class="headerlink" title="5、mv命令"></a>5、mv命令</h4><p>功能：将文件移动走，或者改名，在uinx下面没有改名的命令，如果想改名，可以使用该命令<br>mv source target　将文件source更名为target</p><h4 id="6、diff"><a href="#6、diff" class="headerlink" title="6、diff"></a>6、diff</h4><p>功能：比较文件内容<br>diff dir1 dir2　比较目录1与目录2的文件列表是否相同，但不比较文件的实际内容，不同则列出<br>diff file1 file2　比较文件1与文件2的内容是否相同，如果是文本格式的文件，则将不相同的内容显示，如果是二进制代码则只表示两个文件是不同的<br>comm file1 file2　比较文件，显示两个文件不相同的内容</p><h4 id="7、ln命令"><a href="#7、ln命令" class="headerlink" title="7、ln命令"></a>7、ln命令</h4><p>功能：建立链接。windows的快捷方式就是根据*inx下的链接的原理来做的<br>ln source_path target_path 硬连接<br>ln -s source_path target_path 软连接</p><h2 id="二、查看文件内容命令"><a href="#二、查看文件内容命令" class="headerlink" title="二、查看文件内容命令"></a>二、查看文件内容命令</h2><h4 id="1、cat命令"><a href="#1、cat命令" class="headerlink" title="1、cat命令"></a>1、cat命令</h4><p>显示文件的内容，和DOS的type相同<br>cat file</p><h4 id="2、more命令"><a href="#2、more命令" class="headerlink" title="2、more命令"></a>2、more命令</h4><p>功能：分页显示命令<br>more　file<br>more命令也可以通过管道符(|)与其他的命令一起使用,例如：<br>ps ux|more<br>ls|more</p><h4 id="3、tail-命令"><a href="#3、tail-命令" class="headerlink" title="3、tail 命令"></a>3、tail 命令</h4><p>功能：显示文件的最后几行<br>tail -n 100 aaa.txt  显示文件aaa.txt文件的最后100行<br>tail -f /var/log/messages  使tail不停地去读最新的内容，这样有实时监视的效果</p><h4 id="4、vi命令"><a href="#4、vi命令" class="headerlink" title="4、vi命令"></a>4、vi命令</h4><p>vi file　编辑文件file<br>vi 原基本使用及命令：<br>在命令模式下，按一下”a”（”A”）键或者”i” （”I”）或者”o”（”O”）键，即进入插入态文本输入模式。在文本输入模式下，按Esc键，即回到命令模式。</p><p>  按”a”键，插入到当前光标的后面；按”i”键，在当前光标处插入；按”A”键，在当前光 标所在行的最后插入；按”I”键，在当前光标所在行的开头插入。</p><p> 退出Vi 的方式: 先按[ESC]键回到命令模式，然后输入:w(写入文件),:w!(不询问方式写入文件）,:wq保存并退出,:q退出,q!不保存退出,：x 该命令的功能同命令模式下的ZZ命令功能相同</p><p>在命令模式中，连按两次大写字母Z，若当前编辑的文件曾被修改过，则Vi保存该文件后退出，返回到shell；若当前编辑的文件没被修改过，则Vi直接退出, 返回到shell。</p><h4 id="5、touch命令"><a href="#5、touch命令" class="headerlink" title="5、touch命令"></a>5、touch命令</h4><p>功能：创建一个空文件<br>touch aaa.txt  创建一个空文件，文件名为aaa.txt</p><h2 id="三、基本系统命令"><a href="#三、基本系统命令" class="headerlink" title="三、基本系统命令"></a>三、基本系统命令</h2><h4 id="1、man命令"><a href="#1、man命令" class="headerlink" title="1、man命令"></a>1、man命令</h4><p>功能：查看某个命令的帮助，如果你不知道某个命令的用法不懂，可以问他，他知道就回告诉你<br>例如：<br>man ls 显示ls命令的帮助内容</p><h4 id="2、w命令"><a href="#2、w命令" class="headerlink" title="2、w命令"></a>2、w命令</h4><p>功能：显示登录用户的详细信息<br>例如：<br>[liujl@signal ~]$ w<br>16:51:13 up  4:20,  1 user,  load average: 0.00, 0.00, 0.00<br>USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT<br> root     pts/0    192.168.56.1     12:31    0.00s  0.11s  0.00s w</p><h4 id="3、who命令"><a href="#3、who命令" class="headerlink" title="3、who命令 　　"></a>3、who命令 　　</h4><p>功能：显示登录用户<br>例如：<br>[root@signal u01]# who<br>root     pts/0        2016-03-21 12:31 (192.168.56.1)</p><h4 id="4、last命令"><a href="#4、last命令" class="headerlink" title="4、last命令"></a>4、last命令</h4><p>功能：查看最近那些用户登录系统</p><p>例如：</p><pre><code><pre><code class="hljs shell">[root@signal u01]# last   root     pts/0        192.168.56.1     Mon Mar 21 12:31   still logged in      reboot   system boot  2.6.32-358.el6.x Mon Mar 21 12:31 - 16:53  (04:21)       root     pts/0        192.168.56.1     Mon Feb  1 17:15 - down   (04:29)       reboot   system boot  2.6.32-358.el6.x Mon Feb  1 17:14 - 21:44  (04:30)       root     pts/0        192.168.56.1     Mon Jan 25 18:46 - down   (00:00)       root     pts/0        192.168.56.1     Mon Jan 25 09:24 - 18:46  (09:22)       reboot   system boot  2.6.32-358.el6.x Mon Jan 25 08:53 - 18:46  (09:53)       reboot   system boot  2.6.32-358.el6.x Fri Jan 22 17:58 - 17:58  (00:00)       root     pts/0        192.168.56.1     Fri Jan 22 10:20 - down   (07:37)       reboot   system boot  2.6.32-358.el6.x Fri Jan 22 09:57 - 17:58  (08:01)       root     pts/2        192.168.56.1     Mon Jan 18 09:23 - down   (06:20)       root     pts/1        192.168.56.1     Mon Jan 18 09:21 - down   (06:23)       root     pts/0        :0.0             Mon Jan 18 09:18 - down   (06:26)       root     tty1         :0               Mon Jan 18 09:18 - down   (06:26)       reboot   system boot  2.6.32-358.el6.x Mon Jan 18 09:17 - 15:44  (06:27)       reboot   system boot  2.6.32-358.el6.x Mon Jan 18 09:15 - 09:17  (00:01)</code></pre>wtmp begins Mon Jan 18 09:15:27 2016</code></pre><h4 id="5、date命令"><a href="#5、date命令" class="headerlink" title="5、date命令"></a>5、date命令</h4><p>功能：系统日期设定<br>date　显示当前日期时间<br>date -s 20:30:30　设置系统时间为20:30:30<br>date -s 2002-3-5　设置系统时期为2003-3-5<br>date -s “060520 06:00:00″　设置系统时期为2006年5月20日6点整。</p><h4 id="6、clock命令"><a href="#6、clock命令" class="headerlink" title="6、clock命令"></a>6、clock命令</h4><p>功能：时钟设置<br>clock –r　对系统Bios中读取时间参数<br>clock –w　将系统时间(如由date设置的时间)写入Bios</p><h4 id="7、uname命令"><a href="#7、uname命令" class="headerlink" title="7、uname命令"></a>7、uname命令</h4><p>功能：查看系统版本<br>uname -R　显示操作系统内核的version<br>例如：<br>[root@signal u01]# uname -a<br>Linux signal 2.6.32-358.el6.x86_64 #1 SMP Tue Jan 29 11:47:41 EST 2013 x86_64 x86_64 x86_64 GNU/Linux</p><h4 id="8、关闭和重新启动系统命令"><a href="#8、关闭和重新启动系统命令" class="headerlink" title="8、关闭和重新启动系统命令"></a>8、关闭和重新启动系统命令</h4><p>reboot　  重新启动计算机<br>shutdown -r now  重新启动计算机，停止服务后重新启动计算机<br>shutdown -h now  关闭计算机，停止服务后再关闭系统<br>halt   关闭计算机<br>一般用shutdown -r now,在重启系统是，关闭相关服务，shutdown -h now也是如此。</p><h4 id="9、su命令"><a href="#9、su命令" class="headerlink" title="9、su命令"></a>9、su命令</h4><p>功能：切换用户<br>su -  切换到root用户</p><p>su – liujl 切换到liujl用户，<br>注意：- ，他很关键，使用-，将使用用户的环境变量</p><h2 id="四、监视系统状态命令"><a href="#四、监视系统状态命令" class="headerlink" title="四、监视系统状态命令"></a>四、监视系统状态命令</h2><h4 id="1、top命令"><a href="#1、top命令" class="headerlink" title="1、top命令"></a>1、top命令</h4><p>功能：实时显示系统中各个进程的资源占用状况</p><h4 id="2、free命令"><a href="#2、free命令" class="headerlink" title="2、free命令"></a>2、free命令</h4><p>功能：查看内存和swap分区使用情况<br>例如：<br>[root@signal u01]# free -m<br>                 total       used       free     shared    buffers     cached<br>Mem:          1878        543       1335          0         54        285<br>    -/+ buffers/cache:        203       1675<br> Swap:         2047          0       2047</p><h4 id="3、uptime"><a href="#3、uptime" class="headerlink" title="3、uptime"></a>3、uptime</h4><p>功能：现在的时间 ，系统开机运转到现在经过的时间，连线的使用者数量，最近一分钟，五分钟和十五分钟的系统负载<br>例如：</p><pre><code class="hljs shell">[root@signal u01]# uptime16:56:04 up  4:24,  1 user,  load average: 0.00, 0.00, 0.00</code></pre><h4 id="4、vmstat命令"><a href="#4、vmstat命令" class="headerlink" title="4、vmstat命令"></a>4、vmstat命令</h4><p>功能：监视虚拟内存使用情况<br>例如：<br>[root@signal u01]# vmstat<br>procs ———–memory———- —swap– —–io—- –system– —–cpu—–<br>r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st<br> 0  0      0 1367156  55808 292620    0    0    22     3   12   13  0  0 98  1  0</p><h4 id="5、ps命令"><a href="#5、ps命令" class="headerlink" title="5、ps命令"></a>5、ps命令</h4><p>功能：显示进程信息<br>ps ux 显示当前用户的进程<br>ps uxwww 显示当前用户的进程的详细信息<br>ps aux 显示所有用户的进程<br>ps ef 显示系统所有进程信息</p><h4 id="6、kill命令"><a href="#6、kill命令" class="headerlink" title="6、kill命令"></a>6、kill命令</h4><p>功能：干掉某个进程，进程号可以通过ps命令得到<br>kill -9 1001　将进程编号为1001的程序干掉<br>kill all -9 apache　将所有名字为apapche的程序杀死，kill不是万能的，对僵死的程序则无效。<br>kill -STOP [pid]    发送SIGSTOP (17,19,23)停止一个进程，而并不消灭这个进程。<br>kill -CONT [pid]    发送SIGCONT (19,18,25)重新开始一个停止的进程。<br>kill -KILL [pid]    发送SIGKILL (9)强迫进程立即停止，并且不实施清理操作。<br>kill -9 -1   终止你拥有的全部进程。<br>SIGKILL和SIGSTOP信号不能被捕捉、封锁或者忽略，但是，其它的信号可以</p><h2 id="五、磁盘操作命令"><a href="#五、磁盘操作命令" class="headerlink" title="五、磁盘操作命令"></a>五、磁盘操作命令</h2><h4 id="1、df命令"><a href="#1、df命令" class="headerlink" title="1、df命令"></a>1、df命令</h4><p>功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br>参数 功能<br>-a 列出全部目录<br>-Ta 列出全部目录，并且显示文件类型<br>-B 显示块信息<br>-i 以i节点列出全部目录<br>-h 按照日常习惯显示（如：1K、100M、20G）<br>-x [filesystype] 不显示[filesystype]<br>例如：<br>[root@signal u01]# df -Th<br>Filesystem    Type    Size  Used Avail Use% Mounted on<br>/dev/sda3     ext4     23G   14G  8.0G  63% /<br>tmpfs        tmpfs    940M   72K  940M   1% /dev/shm<br>/dev/sda1     ext4    194M   32M  153M  18% /boot</p><h4 id="2、du命令"><a href="#2、du命令" class="headerlink" title="2、du命令"></a>2、du命令</h4><p>功能：检测一个目录和（递归地）所有它的子目录中的文件占用的磁盘空间。<br>参数  功能<br>-s [dirName] 显示目录占用总空间<br>-sk [dirName] 显示目录占用总空间，以k为单位<br>-sb [dirName] 显示目录占用总空间，以b为单位<br>-sm [dirName] 显示目录占用总空间，以m为单位<br>-sc [dirName] 显示目录占用总空间，加上目录统计<br>-sh [dirName] 只统计目录大小</p><p>例如：<br>[root@signal u01]# du -sh app<br>5.8G    app</p><h4 id="3、mount命令"><a href="#3、mount命令" class="headerlink" title="3、mount命令"></a>3、mount命令</h4><p>功能：使用mount命令就可在Linux中挂载各种文件系统。<br>格式：mount -t &lt;文件系统&gt; 设备名 挂载点<br>(1)mount /dev/sda1  /mnt/filetest<br>mount -t vfat /dev/hda  /mnt/fatfile<br>mount -t ntfs /dev/hda  /mnt/ntfsfile<br>mount -t iso9660 /dev/cdrom  /mnt/cdrom<br>mount -o &lt;选项&gt; 设备名 挂载点</p><p>(2)使用usb设备<br>modprobe usb-storage<br>mkdir /mnt/usb<br>mount -t auto /dev/sdx1 /mnt/usb<br>umount /mnt/usb</p><h4 id="4、mkswap命令"><a href="#4、mkswap命令" class="headerlink" title="4、mkswap命令"></a>4、mkswap命令</h4><p>功能：使用mkswap命令可以创建swap空间，如：<br>debian:<del># mkswap -c /dev/hda4<br>debian:</del># swapon /dev/hda4      #启用新创建的swap空间，停用可使用swapoff命令</p><h4 id="5、fdisk命令"><a href="#5、fdisk命令" class="headerlink" title="5、fdisk命令"></a>5、fdisk命令</h4><p>功能：对磁盘进行分区<br>fdisk /dev/xxx 格式化xxx设备(xxx是指磁盘驱动器的名字，例如hdb，sdc)<br>fdisk -l 显示磁盘的分区表</p><h4 id="6、mkfs命令"><a href="#6、mkfs命令" class="headerlink" title="6、mkfs命令"></a>6、mkfs命令</h4><p>功能：格式化文件系统，可以指定文件系统的类型，如ext2、ext3、fat、ntfs等<br>格式1：mkfs.ext3 options /dev/xxx<br>格式2：mkfs -t ext2 options /dev/xxx<br>参数   功能<br>-b &lt;1024|2048|4096&gt; 块大小<br>-i <number>  节点大写<br>-m <number>  预留管理空间大小<br>例如：<br>debian:~#mkfs.ext4 /dev/sdb1</p><h4 id="7、e2fsck命令"><a href="#7、e2fsck命令" class="headerlink" title="7、e2fsck命令"></a>7、e2fsck命令</h4><p>功能：磁盘检测<br>e2fsck /dev/hda1　检查/dev/hda1是否有文件系统错误，提示修复方式<br>e2fsck -p /dev/hda1　检查/dev/hda1是否有错误，如果有则自动修复<br>e2fsck -y /dev/hda1　检查错误，所有提问均于yes方式执行<br>e2fsck -c /dev/hda1　检查磁盘是否有坏区</p><h4 id="8、tune2fs命令"><a href="#8、tune2fs命令" class="headerlink" title="8、tune2fs命令"></a>8、tune2fs命令</h4><p>功能：调整ext2/ext3文件的参数<br>参数  功能<br>-l <device> 查看文件系统信息<br>-c <count> 设置强制自检的挂载次数<br>-i <n day> 设置强制自检的间隔时间，单位天<br>-m <percentage> 保留块的百分比<br>-j  将ext2文件系统转换成ext3格式</p><p>tune2fs -l /dev/sda1</p><h4 id="9、dd命令"><a href="#9、dd命令" class="headerlink" title="9、dd命令"></a>9、dd命令</h4><p>功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。<br>跟DOS下的diskcopy命令的作用类似。<br>dd if=/dev/fd0 of=floppy.img　将软盘的内容复制成一个镜像<br>dd if=floppy.img of=/dev/fd0　将一个镜像的内容复制到软盘，做驱动盘的时候经常用。</p><h2 id="六、用户和组相关命令"><a href="#六、用户和组相关命令" class="headerlink" title="六、用户和组相关命令"></a>六、用户和组相关命令</h2><h4 id="1、groupadd命令"><a href="#1、groupadd命令" class="headerlink" title="1、groupadd命令"></a>1、groupadd命令</h4><p>　　功能：添加组<br>　　groupadd dba  添加dba组<br>　　groupadd -g 1001 dba  添加dba组，组id为1001</p><h4 id="2、useradd命令"><a href="#2、useradd命令" class="headerlink" title="2、useradd命令"></a>2、useradd命令</h4><p>功能：添加用户<br>　　useradd liujl  添加用户，home为/home/user1，组为user1<br>　　useradd -g dba -m -d /home/liujl liujl 添加用户liujl，home为/home/liujl，组为liujl<br>　　user list　显示已登陆的用户列表</p><h4 id="3、passwd命令"><a href="#3、passwd命令" class="headerlink" title="3、passwd命令"></a>3、passwd命令</h4><p>功能：更改用户密码<br>　　passwd liujl　修改用户user1的密码<br>　　passwd -d root　将root用户的密码删除</p><h4 id="4、userdel命令"><a href="#4、userdel命令" class="headerlink" title="4、userdel命令"></a>4、userdel命令</h4><p>功能：删除用户<br>　　userdel liujl　删除liujl用户</p><h4 id="5、chown命令"><a href="#5、chown命令" class="headerlink" title="5、chown命令"></a>5、chown命令</h4><p>功能：改变文件或目录的所有者<br>　　chown liujl /dir　将/dir目录设置为user1所有<br>　　chown -R liujl:dba /dir　将/dir目录下所有文件和目录，设置为liujl所有,组为dba。-R递归到下面的每个文件和目录</p><h4 id="6、chgrp命令"><a href="#6、chgrp命令" class="headerlink" title="6、chgrp命令"></a>6、chgrp命令</h4><p>功能：改变文件或目录的所有组<br>　　chgrp dba /dir　将/dir目录设置为dba所有</p><h4 id="7、chmod命令"><a href="#7、chmod命令" class="headerlink" title="7、chmod命令"></a>7、chmod命令</h4><p>功能：改变用户的权限<br>　　chmod a+x file　将file文件设置为可执行，脚本类文件一定要这样设置一个，否则得用bash file才能执行<br>　　chmod 666 file　将文件file设置为可读写<br>　　chmod 750 file 将文件file设置为，所有者为完全权限，同组可以读和执行，其他无权限</p><h4 id="8、id命令"><a href="#8、id命令" class="headerlink" title="8、id命令"></a>8、id命令</h4><p>功能：显示用户的信息，包括uid、gid等</p><p>id liujl</p><p>uid=1002(liujl) gid=1002(liujl) groups=1002(liujl)</p><h4 id="9、finger命令"><a href="#9、finger命令" class="headerlink" title="9、finger命令"></a>9、finger命令</h4><p>功能：显示用户的信息<br>注意：debian下没有该命令。</p><p>finger liujl</p><p>　　Login: liujl                           Name:<br>　　Directory: /home/liujl                 Shell: /bin/bash<br>　　On since Mon Mar 21 07:59 (CST) on pts/0 from 192.168.56.10<br>　　No mail.<br>　　No Plan.</p><h2 id="七、压缩命令"><a href="#七、压缩命令" class="headerlink" title="七、压缩命令"></a>七、压缩命令</h2><h4 id="1、gzip格式命令"><a href="#1、gzip格式命令" class="headerlink" title="1、gzip格式命令"></a>1、gzip格式命令</h4><p>功能：压缩文件，gz格式的<br>注意：生成的文件会把源文件覆盖<br>　　gzip -v <filename> 压缩文件，并且显示进度<br>　　-d <filename> 解压缩<br>　　gnuzip  -f <filename> 解压缩<br>例如：</p><p>gzip 1.sh</p><p>　　#ll<br>　　-rw-r–r–. 1 root   root       25 Mar 21 17:10 1.sh.gz</p><h4 id="2、zip格式命令"><a href="#2、zip格式命令" class="headerlink" title="2、zip格式命令"></a>2、zip格式命令</h4><p>功能：压缩和解压缩zip命令<br>zip  <DSTfilename> <SRCfilename><br>unzip  <filename><br>例如：</p><p>zip a.sh.zip a.sh</p><p>adding: a.sh (stored 0%)</p><p>ll</p><p>　　-rw-r–r–    1 root     root          188  5月 21 10:37 a.sh.zip</p><p>unzip a.sh.zip</p><p>Archive:  a.sh.zip<br>replace a.sh? [y]es, [n]o, [A]ll, [N]one, [r]ename: r<br>new name: a1.sh<br>extracting: a1.sh</p><p>ll</p><p>　　-rwxr-xr-x    1 root     root           48 12月 18 21:08 a1.sh</p><h4 id="3、bzip2根式命令"><a href="#3、bzip2根式命令" class="headerlink" title="3、bzip2根式命令"></a>3、bzip2根式命令</h4><p>功能：bzip2格式压缩命令，<br>注意：生成的文件会把源文件覆盖<br>bzip2   <filename><br>bunzip2 <filename><br>例如：</p><p>bzip2 a.sh</p><p>　　# ll<br>　　-rwxr-xr-x    1 root     root           85 12月 18 21:08 a.sh.bz2</p><p>bunzip2 a.sh.bz2</p><p>　　# ll<br>　　-rwxr-xr-x    1 root     root           48 12月 18 21:08 a.sh</p><h4 id="4、tar命令"><a href="#4、tar命令" class="headerlink" title="4、tar命令"></a>4、tar命令</h4><p>功能：归档、压缩等，比较重要，会经常使用。<br>　　-cvf  &lt;DSTfilename.tar&gt; <SRCfilename> 压缩文件或目录<br>　　-xvf  <SRCfilename>   解压缩文件或目录<br>　　-zcvf  <DSTfilename> <SRCfilename> 压缩文件，格式tar.gz<br>　　-zxvf  <DSTfilename> <SRCfilename> 解压缩文件，格式tar.gz<br>　　-zcvf  &lt;DST.tgz&gt; <SRCfilename>  压缩文件，格式tgz<br>　　-zxvf  &lt;DST.tgz&gt; <SRCfilename>  解压缩文件，格式tgz</p><p>tar xzvf abc.tar.gz</p><h2 id="八、网络相关命令"><a href="#八、网络相关命令" class="headerlink" title="八、网络相关命令"></a>八、网络相关命令</h2><h4 id="1、ifconfig命令"><a href="#1、ifconfig命令" class="headerlink" title="1、ifconfig命令"></a>1、ifconfig命令</h4><p>功能：显示修改网卡的信息<br>　　ifconfig  显示网络信息<br>　　ifconfig eth0 显示eth0网络信息<br>修改网络信息：<br>　　ifconfig eth0 192.168.1.1 netmask 255.255.255.0 设置网卡1的地址192.168.1.1，掩码为255.255.255.0<br>　　ifconfig eth0:1 192.168.1.2　   捆绑网卡1的第二个地址为192.168.1.2<br>　　ifconfig eth0:x 192.168.1.n　   捆绑网卡1的第n个地址为192.168.1.n　　</p><h4 id="2、route命令"><a href="#2、route命令" class="headerlink" title="2、route命令"></a>2、route命令</h4><p>功能：显示当前路由设置情况<br>　　route 显示当前路由设置情况，比较慢一般不用。<br>　　route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254  添加静态路由<br>　　route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254  添加静态路由<br>　　route add default gw 192.168.1.1 metric1　   设置192.168.1.1为默认的路由<br>　　route del default　      将默认的路由删除</p><p>举例：</p><p>route add -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>netstat -nr</p><p>　　Kernel IP routing table<br>　　Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>　　192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0<br>　　10.0.0.0        192.168.1.254   255.255.0.0     UG        0 0          0 eth0<br>　　169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0<br>　　0.0.0.0         192.168.1.254   0.0.0.0         UG        0 0          0 eth0</p><p>route del -net 10.0.0.0 netmask 255.255.0.0 gw 192.168.1.254</p><p>netstat -nr</p><p>　　Kernel IP routing table<br>　　Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>　　192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0<br>　　169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 eth0<br>　　0.0.0.0         192.168.1.254   0.0.0.0         UG        0 0          0 eth0</p><h4 id="3、netstat命令"><a href="#3、netstat命令" class="headerlink" title="3、netstat命令"></a>3、netstat命令</h4><p>功能：显示网络状态<br>　　netstat -an  查看网络端口信息<br>　　netstat -nr 查看路由表信息，比route快多了<br>　　-t: 显示TCP链接信息<br>　　-u: 显示UDP链接信息<br>　　-l: 显示监听状态的端口<br>　　-n: 直接显示ip，不做名称转换<br>　　-p: 显示相应的进程PID以及名称（要root权限）<br>　　如果要查看关于sockets更详细占用信息等，可以使用lsof工具。</p><h4 id="4、启动网络的命令"><a href="#4、启动网络的命令" class="headerlink" title="4、启动网络的命令"></a>4、启动网络的命令</h4><p>redhat族的命令:<br>　　/etc/init.d/network<br>　　debian命令:<br>　　/etc/init.d/networking<br>例如：<br>　　/etc/init.d/network stop 停止网络，<br>　　/etc/init.d/network start 启动网络，</p><h4 id="5、手工修改网络配置"><a href="#5、手工修改网络配置" class="headerlink" title="5、手工修改网络配置"></a>5、手工修改网络配置</h4><p><strong>(1)、debian系统</strong><br>配置文件位置为：/etc/network/interfaces</p><p>The loopback network interface</p><p>　　auto lo<br>　　iface lo inet loopback</p><p>The primary network interface</p><p>　　auto eth0 eth1<br>　　iface eth0 inet static<br>　　address 10.4.5.6<br>　　netmask 255.255.255.0<br>　　network 10.4.5.0<br>　　broadcast 10.4.5.255<br>　　iface eth1 inet static<br>　　address 219.25.5.60<br>　　netmask 255.255.255.192<br>　　network 219.25.5.0<br>　　broadcast 219.25.5.63<br>　　gateway 219.25.5.30<br>　　修改后保存配置后，运行<br>　　/etc/init.d/networking restart<br>　　网络配置就改变了</p><p><strong>(2)、redhat系统</strong><br>　　配置文件位置为：/etc/sysconfig/network-scripts/ifcfg-eth0<br>　　DEVICE=eth0<br>　　BOOTPROTO=static<br>　　BROADCAST=192.168.1.255<br>　　IPADDR=192.168.1.5<br>　　NETMASK=255.255.255.0<br>　　NETWORK=192.168.1.0<br>　　GATEWAY=192.168.1.254<br>　　ONBOOT=yes<br>　　TYPE=Ethernet<br>　　修改后保存配置后，运行<br>　　/etc/init.d/network restart<br>　　或者<br>　　service network restart<br>　　网络配置就改变了。<br>　　默认DNS的文件的位置为：/etc/resolv.conf<br>　　#cat /etc/resolv.conf<br>　　search test.com.cn<br>　　nameserver 192.168.1.11</p><h4 id="6、网络排错"><a href="#6、网络排错" class="headerlink" title="6、网络排错"></a>6、网络排错</h4><p><strong>(1)、ping命令</strong><br>　　功能：不说了，不知道就用干这行了。<br>　　ping <a href="http://www.163.com/">www.163.com</a><br><strong>(2)、traceroute命令</strong></p><p>　　功能：路由跟踪<br>　　traceroute <a href="http://www.163.com/">www.163.com</a><br>　　traceroute 207.68.173.7</p><p><strong>(3)、nslookup命令</strong></p><p>　　功能：域名解析排错<br>　　例如：<br>　　$ nslookup</p><h2 id="九、其他命令"><a href="#九、其他命令" class="headerlink" title="九、其他命令"></a>九、其他命令</h2><h4 id="1、ssh命令"><a href="#1、ssh命令" class="headerlink" title="1、ssh命令"></a>1、ssh命令</h4><p>功能：远程登陆到其他UNIX主机<br>　　ssh -l user1 192.168.1.2 使用用户名user1登陆到192.168.1.2<br>　　ssh <a href="mailto:&#x75;&#x73;&#x65;&#114;&#49;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#49;&#46;&#x32;">&#x75;&#x73;&#x65;&#114;&#49;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#56;&#x2e;&#49;&#46;&#x32;</a>   使用用户名user1登陆到192.168.1.2</p><h4 id="2、scp命令"><a href="#2、scp命令" class="headerlink" title="2、scp命令"></a>2、scp命令</h4><p>功能：安全copy<br>例如：<br>　　scp abc.tar.gz <a href="mailto:&#117;&#115;&#x65;&#x72;&#49;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#46;&#53;">&#117;&#115;&#x65;&#x72;&#49;&#64;&#49;&#x39;&#x32;&#46;&#x31;&#54;&#x38;&#46;&#x31;&#46;&#53;</a>:~ 将本地的abc.tar.gz 复制到 192.168.1.5的user1用户的根(/home/user1)下。</p><h4 id="3、telnet命令"><a href="#3、telnet命令" class="headerlink" title="3、telnet命令"></a>3、telnet命令</h4><p>功能：登陆到远程主机<br>例如：</p><p>　　telnet 192.168.1.5</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10连接wsl2子系统ubuntu18.04图形界面</title>
    <link href="/2020/11/23/win10%E8%BF%9E%E6%8E%A5wsl2%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu18.04%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    <url>/2020/11/23/win10%E8%BF%9E%E6%8E%A5wsl2%E5%AD%90%E7%B3%BB%E7%BB%9Fubuntu18.04%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="win10连接wsl2子系统ubuntu18-04图形界面"><a href="#win10连接wsl2子系统ubuntu18-04图形界面" class="headerlink" title="win10连接wsl2子系统ubuntu18.04图形界面"></a>win10连接wsl2子系统ubuntu18.04图形界面</h1><p>网上很多教程很多是用的 xfce4 和 VcXsrv ，虽然也可以，但是本次想玩点花的，所以想用 gnome 加上win10自带的远程桌面程序来连接，我记得之前连服务器的时候就是用的win10自带的远程桌面程序，感觉也挺好用的，不知道为啥网上都是用 VcXsrv 。。。而且主要是感觉过程也不怎么简单，还要另外下远程连接的软件，下载的速度还贼慢。。。安装的整个过程也是相当曲折，一方面网上关于这方面的基本搜不到，我也只查了很多零零散散的博客和资料看了之后将各种方法拼凑了一下。</p><p>中途遇到一些坑，导致wsl直接启动不了，重装也无济于事。。。索性最后成功了。为了以后不再踩同样的坑，在这里记录一下。</p><h3 id="1、安装systemd"><a href="#1、安装systemd" class="headerlink" title="1、安装systemd"></a>1、安装systemd</h3><p>查的资料说 gnome 桌面是基于 systemd 的，但是目前(2020.11.23) WSL 还不自带 systemd ，反正还有点问题吧，然后就只能我们自己安装，这里就是第一个坑，也就是<strong>导致 WSL 进不去的原因</strong>。</p><p>首先，我们在安装systemd之前一定要检查一下自己的WSL 系统有没有 <strong>daemonize</strong>  ，没有的话需要提前安装，不然之后安装了systemd会导致进不去WSL：</p><p><img src="https://pic.cloudfor.top/blog/2YjG4zlu8SmJvyq.png" alt="没装dasmonize"></p><p>查看有没有 <strong>daemonize</strong>：</p><pre><code class="hljs java">which daemonize</code></pre><p>如果有的话会输出路径信息，例如：/usr/bin/daemonize</p><p>如果什么都没有输出的话就是没有了。可以用以下命令安装：</p><pre><code class="hljs java">sudo apt-get install daemonize</code></pre><p>装好之后，就可以继续安装systemd了。运行命令更新软件列表：</p><pre><code class="hljs java">sudo apt update</code></pre><p>然后需要安装git，安装过的可以不用：</p><pre><code class="hljs java">sudo apt install git</code></pre><p>下载<strong>systemd</strong>：</p><pre><code class="hljs java">git clone https:<span class="hljs-comment">//github.com/DamionGans/ubuntu-wsl2-systemd-script.git</span></code></pre><p>进入目录：</p><pre><code class="hljs java">cd ubuntu-wsl2-systemd-script/</code></pre><p>运行：</p><pre><code class="hljs java">bash ubuntu-wsl2-systemd-script.sh</code></pre><p>这就安装完成了，然后重启WSL子系统或者重启电脑。</p><h3 id="2、安装gnome桌面"><a href="#2、安装gnome桌面" class="headerlink" title="2、安装gnome桌面"></a>2、安装gnome桌面</h3><pre><code class="hljs java">sudo apt updatesudo apt install -y ubuntu-desktop</code></pre><p>安装好之后安装Xrdp：</p><pre><code class="hljs java">sudo apt install -y xrdpsudo systemctl status xrdp</code></pre><pre><code class="hljs java">sudo adduser xrdp ssl-certsudo systemctl restart xrdp</code></pre><p>看一下端口，一般默认是 3389 ：</p><pre><code class="hljs java">vim /etc/xrdp/xrdp.ini</code></pre><p>配置防火墙：</p><pre><code class="hljs java">sudo ufw allow <span class="hljs-number">3389</span></code></pre><p>马上就大功告成了！</p><h3 id="3、连接远程桌面"><a href="#3、连接远程桌面" class="headerlink" title="3、连接远程桌面"></a>3、连接远程桌面</h3><p>注意连接的时候一定要保持xrdp服务运行，重启wsl之后要打开一下。</p><p><img src="https://pic.cloudfor.top/blog/Hq93eRSKoNYWnQC.png" alt="win10远程桌面1"></p><p>输入wsl的账号密码：</p><p><img src="https://pic.cloudfor.top/blog/Q5R3EFJmTKZC4fi.png" alt="win10远程桌面连接登录"></p><p><a href="https://pic.cloudfor.top/blog">https://pic.cloudfor.top/blog</a></p><p>进入桌面：</p><p><img src="https://pic.cloudfor.top/blog/pfKWLguNmi2YrtQ.png" alt="gnome桌面1"></p><p>大功告成啦！</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动手实操</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云服务器Ubuntu18.04安装jdk</title>
    <link href="/2020/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Ubuntu18.04%E5%AE%89%E8%A3%85jdk/"/>
    <url>/2020/11/18/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8Ubuntu18.04%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<h1 id="云服务器Ubuntu18-04安装jdk"><a href="#云服务器Ubuntu18-04安装jdk" class="headerlink" title="云服务器Ubuntu18.04安装jdk"></a>云服务器Ubuntu18.04安装jdk</h1><p>linux安装java jdk有几种方式，这里讲下我用的方式。就是下载好jdk压缩包，然后解压包再添加好环境变量。</p><h3 id="1、下载压缩包"><a href="#1、下载压缩包" class="headerlink" title="1、下载压缩包"></a>1、下载压缩包</h3><p><a href="https://www.injdk.cn/">https://www.injdk.cn/</a></p><p>这个网址有java jdk 的oracle版和各个openjdk发行版。因为之前刚在windows 的子系统WSL Ubuntu18.04 上安装了jdk,所以我直接把之前下载到windows电脑上的文件上传到了服务器。</p><p>我在 user(自己的用户名)目录下新建了 jdk 文件夹。</p><pre><code class="hljs shell">mkdir jdk</code></pre><p>然后把文件放到 jdk 目录下</p><p><img src="https://pic.cloudfor.top/blog/image-20201118171805737.png" alt="image-20201118171805737"></p><h3 id="2、然后解压文件"><a href="#2、然后解压文件" class="headerlink" title="2、然后解压文件"></a>2、然后解压文件</h3><pre><code class="hljs shell">tar -xzfv zulu8.48.0.53-ca-jdk8.0.265-linux_x64.tar.gz -C /home/ericw/jdk</code></pre><p>更改解压出来的文件夹名：</p><pre><code class="hljs shell">mv zulu8.48.0.53-ca-jdk8.0.265-linux_x64/ jdk8.0.265</code></pre><h3 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h3><p>打开文件:</p><pre><code class="hljs shell">sudo vim ~/.bashrc</code></pre><p>在最后添加：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置环境变量</span>export JAVA_HOME=/home/ericw/jdk/jdk8.0.265  ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jre  export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib  export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</code></pre><p>然后保存退出：</p><pre><code class="hljs shell">:wq</code></pre><p>更新配置文件：</p><pre><code class="hljs shell">source ~/.bashrc</code></pre><p>全部完成，可以查看版本信息验证一下：</p><p><img src="https://pic.cloudfor.top/blog/jdk%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png" alt="jdk安装完成"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>java</tag>
      
      <tag>云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多态经典题</title>
    <link href="/2020/11/16/java%E5%A4%9A%E6%80%81%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <url>/2020/11/16/java%E5%A4%9A%E6%80%81%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java多态经典题"><a href="#Java多态经典题" class="headerlink" title="Java多态经典题"></a>Java多态经典题</h1><p>​        之前看过几次多态的题，当时感觉搞清楚了，但是过一段时间感觉又模糊不确定了，所以记录一下，而且后来在项目中有涉及相关的内容，应该会有更深的体会。</p><p><strong>题目：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.经典多态案例;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDuoTai</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a1 = <span class="hljs-keyword">new</span> A();        A a2 = <span class="hljs-keyword">new</span> B();        B b = <span class="hljs-keyword">new</span> B();        C c = <span class="hljs-keyword">new</span> C();        D d = <span class="hljs-keyword">new</span> D();        System.out.println(<span class="hljs-string">&quot;1--&quot;</span> + a1.show(b) + <span class="hljs-string">&quot;  &quot;</span> + System.identityHashCode(a1));        <span class="hljs-comment">// 为什么会向上找</span>        System.out.println(<span class="hljs-string">&quot;2--&quot;</span> + a1.show(c));        System.out.println(<span class="hljs-string">&quot;3--&quot;</span> + a1.show(d));        System.out.println(<span class="hljs-string">&quot;4--&quot;</span> + a2.show(b) + <span class="hljs-string">&quot;  &quot;</span> + System.identityHashCode(a2));        <span class="hljs-comment">/**(想法1.0)</span><span class="hljs-comment">         多态情况下，a2为A类型的引用，指向B类对象，</span><span class="hljs-comment">         先在B类里找有无该方法，有。但是父类A中没有，于是不能直接用B类的该方法，按照前三个的逻辑先去A类中找，A类中有show(A obj)，但是A的子类B类中重写了show(A obj)，所以调用B类的该方法</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**(想法2.0)</span><span class="hljs-comment">         *多态情况下，a2为A类型的引用，指向B类对象，在A类中找有无该方法，没有，但是A类为B类父类，所以调 *用A类的show(A obj)方法，然后A类的子类B重写了show(A obj)方法，</span><span class="hljs-comment">         * 所以最终调用B类的show(A obj)方法</span><span class="hljs-comment">         * */</span>        <span class="hljs-comment">// 只有方法才有多态性！！！</span>        System.out.println(<span class="hljs-string">&quot;5--&quot;</span> + a2.show(c));        System.out.println(<span class="hljs-string">&quot;6--&quot;</span> + a2.show(d));        System.out.println(<span class="hljs-string">&quot;7--&quot;</span> + b.show(b));        System.out.println(<span class="hljs-string">&quot;8--&quot;</span> + b.show(c));                <span class="hljs-comment">// 这里因为B类继承A类，而A类有该方法，且没被B重写，所以B类中隐含有该方法。</span>        System.out.println(<span class="hljs-string">&quot;9--&quot;</span> + b.show(d));      &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(D obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and D&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;A and A&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num1 = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(B obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and B&quot;</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">show</span><span class="hljs-params">(A obj)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;B and A&quot;</span>);    &#125;    <span class="hljs-comment">/*  子类B中包含了父类A的这两个方法，只是B类重写覆盖了show(A obj)</span><span class="hljs-comment">    public String show(D obj) &#123;</span><span class="hljs-comment">        return (&quot;A and D&quot;);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">    public String show(A obj) &#123;</span><span class="hljs-comment">        return (&quot;A and A&quot;);</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">     */</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">B</span> </span>&#123;&#125;</code></pre><p><strong>注意：</strong>对于a2的情况，也就是父类引用指向子类对象的，a2是无法调用A类中没有而B类中有的方法的。也就是对于子类独有的方法，这个父类引用是无法调用的。</p><p>运行结果：</p><blockquote><p>1–A and A  460141958<br>2–A and A<br>3–A and D<br>4–B and A  1163157884<br>5–B and A<br>6–A and D<br>7–B and B<br>8–B and B<br>9–A and D</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win10子系统迁移安装目录到非系统盘</title>
    <link href="/2020/11/13/win10%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E5%88%B0%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98/"/>
    <url>/2020/11/13/win10%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%81%E7%A7%BB%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E5%88%B0%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Win10子系统迁移安装目录到非系统盘"><a href="#Win10子系统迁移安装目录到非系统盘" class="headerlink" title="Win10子系统迁移安装目录到非系统盘"></a>Win10子系统迁移安装目录到非系统盘</h1><p>​        因为电脑C盘吃紧，但是win10默认从Microsoft安装的软件都是在C盘的，安装完wsl之后，还要更新软件安装新软件之类的，这又要占用C盘空间，于是想把WSL的安装位置迁移到非系统盘。</p><p>​        之前其实就做过一次，这次在另一台电脑上弄的时候，发现操作好像和之前不一样，网上的都是要下一个 LxRunOffline.exe 的软件来辅助转移。有点疑惑，不知道两个的目的是不是一样，或者两个的操作是不是一个意思，主要是一开始用LxRunOffline.exe迁移失败了，最后wsl拒绝访问。然后重新装了WSL，用第一次的方法操作成功。所以不是太清楚这两个具体有哪些区别，但是目的达到了，因为迁移之后WSL安装的软件就没有安装在C盘了。</p><h3 id="1、查看WSL分发版本"><a href="#1、查看WSL分发版本" class="headerlink" title="1、查看WSL分发版本"></a>1、查看WSL分发版本</h3><p>用管理员权限打开 Windows PowerShell ，输入命令：</p><pre><code class="hljs shell">wsl -l --all -v</code></pre><p>显示如下：</p><pre><code class="hljs shell">NAMESTATEVERSIONUbuntu18.04 Runing 2</code></pre><h3 id="2、导出分发版为tar文件到D盘"><a href="#2、导出分发版为tar文件到D盘" class="headerlink" title="2、导出分发版为tar文件到D盘"></a>2、导出分发版为<strong>tar</strong>文件到D盘</h3><pre><code class="hljs shell">wsl --export Ubuntu-18.04 d:\wsl-ubuntu18.04.tar   #看清楚版本</code></pre><h3 id="3、注销当前分发版"><a href="#3、注销当前分发版" class="headerlink" title="3、注销当前分发版"></a>3、注销当前分发版</h3><pre><code class="hljs shell">wsl --unregister Ubuntu-18.04</code></pre><h3 id="4、重新导入并安装WSL到新的目录下"><a href="#4、重新导入并安装WSL到新的目录下" class="headerlink" title="4、重新导入并安装WSL到新的目录下"></a>4、重新导入并安装WSL到新的目录下</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 前面是新目录路径，后面是导出的tar文件的路径</span>wsl --import Ubuntu-18.04 d:\wsl-ubuntu18.04 d:\wsl-ubuntu18.04.tar --version 2</code></pre><h3 id="5、设置默认登陆用户为安装时用户名"><a href="#5、设置默认登陆用户为安装时用户名" class="headerlink" title="5、设置默认登陆用户为安装时用户名"></a>5、设置默认登陆用户为安装时用户名</h3><pre><code class="hljs shell">ubuntu1804 config --default-user Username#注意前面的版本号，最后Username写自己的用户名</code></pre><h3 id="6、删除tar文件（可选）"><a href="#6、删除tar文件（可选）" class="headerlink" title="6、删除tar文件（可选）"></a>6、删除tar文件（可选）</h3><pre><code class="hljs shell">del d:\wsl-ubuntu18.04.tar</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>技术干货</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 18.04 添加新用户</title>
    <link href="/2020/11/12/Ubuntu18.04%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7/"/>
    <url>/2020/11/12/Ubuntu18.04%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-18-04-添加新用户"><a href="#Ubuntu-18-04-添加新用户" class="headerlink" title="Ubuntu 18.04 添加新用户"></a>Ubuntu 18.04 添加新用户</h1><p>太久没用Linux,每次这些基本的命令都要重新百度找，这里做个记录，方便以后查找。</p><h2 id="1、创建用户"><a href="#1、创建用户" class="headerlink" title="1、创建用户"></a>1、创建用户</h2><p><strong>命令：</strong></p><p>adduer和useradd，对应着两条删除用户的命令：deluser和userdel</p><p>两者的区别：</p><p><strong>adduser:</strong> 会自动为创建的用户指定 <strong>主目录</strong>、<strong>系统shell版本</strong>，而且会在创建时输入<strong>用户密码</strong>。</p><p><strong>useradd:</strong> 需要使用参数手动指定上述的基本设置，如果不使用任何参数，则创建的用户没有密码、主目录，并且没有指定shell版本。</p><h3 id="1-1-adduser"><a href="#1-1-adduser" class="headerlink" title="1.1 adduser"></a>1.1 adduser</h3><p>输入命令：</p><pre><code class="hljs shell">sudo adduser tt</code></pre><p>输出显示：</p><pre><code class="hljs shell">[sudo] password for mqk: 正在添加用户&quot;tt&quot;...正在添加新组&quot;tt&quot; (1006)...正在添加新用户&quot;tt&quot; (1006) 到组&quot;tt&quot;...创建主目录&quot;/home/tt&quot;...正在从&quot;/etc/skel&quot;复制文件...输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码正在改变 tt 的用户信息请输入新值，或直接敲回车键以使用默认值    全名 []:     房间号码 []:     工作电话 []:     家庭电话 []:     其它 []: 这些信息是否正确？ [Y/n] y</code></pre><p>这样在创建用户名时，就创建了用户的主目录以及密码。</p><p>默认情况下：<br>adduser在创建用户时会主动调用 /etc/adduser.conf；<br>在创建用户主目录时默认在/home下，而且创建为 /home/用户名</p><p>如果主目录已经存在，就不再创建，但是此主目录虽然作为新用户的主目录，而且默认登录时会进入这个目录下，但是这个目录并不是属于新用户，当使用userdel删除新用户时，并不会删除这个主目录，因为这个主目录在创建前已经存在且并不属于这个用户。</p><p>为用户指定shell版本为：/bin/bash<br>因此常用参数选项为：</p><ol><li>–home： 指定创建主目录的路径，默认是在/home目录下创建用户名同名的目录，这里可以指定；如果主目录同名目录存在，则不再创建，仅在登录时进入主目录。</li><li>–quiet： 即只打印警告和错误信息，忽略其他信息。</li><li>–debug： 定位错误信息。</li><li>–conf： 在创建用户时使用指定的configuration文件。</li><li>–force-badname： 默认在创建用户时会进行/etc/adduser.conf中的正则表达式检查用户名是否合法，如果想使用弱检查，则使用这个选项，如果不想检查，可以将/etc/adduser.conf中相关选项屏蔽。</li></ol><p><img src="https://pic.cloudfor.top/blog/image-20210105132008777.png" alt="image-20210105132008777"></p><h3 id="1-2-useradd"><a href="#1-2-useradd" class="headerlink" title="1.2 useradd"></a>1.2 useradd</h3><p>一般不怎么用这个，用到了再补。</p><h2 id="2、删除用户"><a href="#2、删除用户" class="headerlink" title="2、删除用户"></a>2、删除用户</h2><h3 id="2-1、deluser"><a href="#2-1、deluser" class="headerlink" title="2.1、deluser"></a>2.1、deluser</h3><p>只删除用户：</p><pre><code class="hljs she">sudo deluser tt</code></pre><p>输出显示：</p><pre><code class="hljs shel">正在删除用户 &#39;tt&#39;...警告：组&quot;tt&quot;没有其他成员了。完成。</code></pre><p>连同用户的主目录和邮箱一起删除：</p><pre><code class="hljs she">sudo deluser --remove-home tt</code></pre><p>输出显示：</p><pre><code class="hljs she">正在寻找要备份或删除的文件...正在删除文件...正在删除用户 &#39;tt&#39;...警告：组&quot;tt&quot;没有其他成员了。完成。</code></pre><p>连同用户拥有的所有文件删除：</p><pre><code class="hljs she">sudo deluser --remove-all-files tt</code></pre><p>相关文件：</p><pre><code class="hljs she">&#x2F;etc&#x2F;passwd - 使 用 者 帐 号 资 讯，可以查看用户信息&#x2F;etc&#x2F;shadow - 使 用 者 帐 号 资 讯 加 密&#x2F;etc&#x2F;group - 群 组 资 讯&#x2F;etc&#x2F;default&#x2F;useradd - 定 义 资 讯&#x2F;etc&#x2F;login.defs - 系 统 广 义 设 定&#x2F;etc&#x2F;skel - 内 含 定 义 档 的 目 录</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小知识点</tag>
      
      <tag>技术干货</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派4b-USB启动</title>
    <link href="/2020/06/25/%E6%A0%91%E8%8E%93%E6%B4%BE4b-USB%E5%90%AF%E5%8A%A8/"/>
    <url>/2020/06/25/%E6%A0%91%E8%8E%93%E6%B4%BE4b-USB%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派4b-USB启动"><a href="#树莓派4b-USB启动" class="headerlink" title="树莓派4b-USB启动"></a>树莓派4b-USB启动</h1><p>新买了树莓派4b,看网上说可以用USB启动，就试了一下，还可以。</p><h3 id="1-下载安装系统"><a href="#1-下载安装系统" class="headerlink" title="1.下载安装系统"></a>1.下载安装系统</h3><p>现在下载64位了：</p><p><a href="https://www.raspberrypi.com/software/operating-systems/">https://www.raspberrypi.com/software/operating-systems/</a></p><p>安装和配置：</p><p><a href="https://blog.csdn.net/m0_50679156/article/details/123613028">https://blog.csdn.net/m0_50679156/article/details/123613028</a></p><p>主要原生树莓派系统需要在刷好系统的SD卡根目录新增一个 ssh 空白文件，以开启ssh 功能。</p><p>raspberry pi OS 64位更换源：</p><pre><code class="hljs sh">sudo nano /etc/apt/sources.list</code></pre><p>注释官方源，增加以下：</p><pre><code class="hljs shell">deb http://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb http://mirrors.aliyun.com/debian-security/ bullseye-security maindeb-src http://mirrors.aliyun.com/debian-security/ bullseye-security maindeb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib</code></pre><p>然后接着需要配置树莓派官方的软件源，编辑</p><pre><code class="hljs shell">sudo nano /etc/apt/sources.list.d/raspi.list</code></pre><p>同样的，注释原内容，在末尾添加如下内容：</p><pre><code class="hljs shell">deb http://mirrors.aliyun.com/raspberrypi/ bullseye main</code></pre><h3 id="2-检查EEPROM-固件"><a href="#2-检查EEPROM-固件" class="headerlink" title="2.检查EEPROM 固件"></a>2.检查EEPROM 固件</h3><p>因为要用USB 启动，所以需要更新 2020 5 月以后的固件，运行以下命令：</p><pre><code class="hljs shell">sudo apt-get updatesudo apt-get upgrade -ysudo rpi-eeprom-update</code></pre><p><strong>EEPROM 相关命令:</strong></p><p>查看当前 EEPROM 版本：</p><pre><code class="hljs shell">vcgencmd bootloader_version</code></pre><p>检查是否可用更新：</p><pre><code class="hljs shell">sudo rpi-eeprom-update</code></pre><p>安装更新：</p><pre><code class="hljs shell">sudo rpi-eeprom-update -asudo reboot</code></pre><p>取消待定更新：</p><pre><code class="hljs shell">sudo rpi-eeprom-update -r</code></pre><p>安装特定的 bootloader EEPROM 镜像：</p><pre><code class="hljs shell">sudo rpi-eeprom-update -d -f pieeprom.bin</code></pre><p>显示内置文档：</p><pre><code class="hljs shell">rpi-eeprom-update -h</code></pre><h3 id="3-安装想要的系统到U盘，硬盘等USB设备"><a href="#3-安装想要的系统到U盘，硬盘等USB设备" class="headerlink" title="3.安装想要的系统到U盘，硬盘等USB设备"></a>3.安装想要的系统到U盘，硬盘等USB设备</h3><p>安装过程和之前一样，下号系统写入就行了。然后关机，把TF卡取出来， 把USB设备插上，启动。</p><p>建议安装ubuntu mate</p><p><a href="https://ubuntu-mate.org/raspberry-pi/">https://ubuntu-mate.org/raspberry-pi/</a></p><p>tips:</p><p>ubuntu 20.0.4镜像源：</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认注释了源码仓库，如有需要可自行取消注释</span>deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main restricted universe multiverse<span class="hljs-meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal main main restricted universe multiverse</span>deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse<span class="hljs-meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse</span>deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse<span class="hljs-meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse</span>deb https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse<span class="hljs-meta">#</span><span class="bash"> deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ focal-security main restricted universe multiverse</span></code></pre><p>参考：</p><p>树莓派4 SSD 启动：<a href="https://zhuanlan.zhihu.com/p/336932291">https://zhuanlan.zhihu.com/p/336932291</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术干货</tag>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
